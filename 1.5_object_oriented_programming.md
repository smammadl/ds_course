# 1.5: Object-Oriented Programming (OOP)

## Introduction to OOP

### OOP vs. Functional Programming

Object-Oriented Programming (OOP) and Functional Programming (FP) are two different paradigms, or ways of thinking about how to structure your code.

| Feature             | Object-Oriented Programming (OOP)                                | Functional Programming (FP)                                       |
| ------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------- |
| **Core Idea**       | Organizes code into objects that bundle data and behavior.       | Treats computation as the evaluation of mathematical functions.     |
| **State**           | Manages state by encapsulating it within objects.                | Avoids or minimizes mutable state, favoring immutable data.        |
| **Data & Operations** | Data (attributes) and operations (methods) are tightly coupled. | Data and functions are separate.                                  |
| **Primary Flow**    | Methods are called on objects.                                   | Functions are composed and passed as arguments.                   |
| **Use Cases**       | Good for large, complex systems where state is central.          | Excellent for data processing, concurrency, and mathematical tasks. |

While they are different, modern languages like Python allow you to mix both styles. For example, you can have a method inside an object that uses a lambda function and `map` to process data. Understanding both helps you choose the best approach for a given problem.

**What is an Object?**

In the real world, everything can be thought of as an object. A car, a dog, a personâ€”they are all objects. Each object has:
- **Attributes:** Characteristics or properties (e.g., a car has a color, model, and year).
- **Methods:** Actions or behaviors it can perform (e.g., a car can `start()`, `drive()`, and `stop()`).

OOP applies this concept to programming. It allows us to structure our code in a way that models real-world objects, making our programs more organized, reusable, and easier to understand.

**Why use OOP?**

- **Modularity:** It breaks down complex problems into smaller, manageable objects.
- **Reusability:** Objects can be reused across different programs (e.g., the `Car` object you define once can be used wherever you need a car).
- **Maintainability:** It's easier to update and maintain code that is well-organized into objects.

## Creating Classes

A **class** is a blueprint for creating objects. It defines the attributes and methods that all objects of that class will have. An **object** (or **instance**) is a specific creation based on that blueprint.

**Think of it like this:** A `CookieCutter` is the class. The `cookies` you make with it are the objects.

### Defining a Class

The `class` keyword is used to define a class. By convention, class names are written in PascalCase.

```python
class Dog:
    pass

print(Dog)
# Output: <class '__main__.Dog'>
```

An instance is a specific occurrence of a class. It is created using the class name as a function.

```python
class Dog:
    pass

my_dog = Dog()
your_dog = Dog()
print(my_dog)
# Output: <__main__.Dog object at 0x000001A323D42250>
type(my_dog)
# Output: '__main__.Dog'
```

An attribute is a variable that is associated with an object. It is defined within the class and is shared by all instances of the class. You can think of it as a characteristic of the object.

```python
class Dog:
    # Class attribute (same for all instances of the class)
    species = "Canis familiaris"

my_dog = Dog()
print(my_dog.species)
# Output: Canis familiaris
```

A method is a function that is associated with an object. It is defined within the class and is shared by all instances of the class. You can think of it as a behavior of the object.

```python
class Dog:
    # Class attribute (same for all instances of the class)
    species = "Canis familiaris"

    # Instance method
    def bark(self):
        return "Woof!"

my_dog = Dog()
print(my_dog.bark())
# Output: Woof!
print(Dog.species)
# Output: Canis familiaris
```

> **Note:** The `self` parameter is a reference to the current instance of the class. It is used to access variables that belong to the class. It must be the first parameter of any method in the class. Technically, you can use any name you want for the `self` parameter, but it is a convention to use `self`.
> ```python
> class Dog:
>     # Class attribute (same for all instances of the class)
>     species = "Canis familiaris"
>     
>     # Instance method
>     def bark(this):
>         return "Woof!"
> ```
> Without self parameter, the method will not know which object it is called on. For example,
> ```python
> class Dog:
>     # Class attribute (same for all instances of the class)
>     species = "Canis familiaris"
>     
>     # Instance method
>     def bark():
>         return "Woof!"
> 
> my_dog = Dog()
> print(my_dog.bark())
> # Output: Error: Dog.bark() takes 0 positional arguments but 1 was given
> print(Dog.bark())
> # Output: Woof!
> ```

There is a special method `__init__` that is called when a new object is created. It is used to initialize the object's attributes.

```python
class Dog:
    # Class attribute (same for all instances of the class)
    species = "Canis familiaris"

    # Initializer / Instance attributes
    def __init__(self, name, age):
        self.name = name  # self.name is an instance attribute
        self.age = age

    # Instance method
    def bark(self):
        return "Woof!"

my_dog = Dog("Buddy", 5)
your_dog = Dog("Lucy", 3)
print(my_dog.name, your_dog.name)
# Output: Buddy Lucy
print(my_dog.age, your_dog.age)
# Output: 5 3
print(my_dog.species, your_dog.species)
# Output: Canis familiaris Canis familiaris
```

> **Note:** Class attributes are shared by all instances of the class. Instance attributes are specific to each instance of the class.

Once a variable is initialized in the `__init__` method, it can be accessed by using the `self` keyword.

```python
class Dog:
    # Class attribute (same for all instances of the class)
    species = "Canis familiaris"

    # Initializer / Instance attributes
    def __init__(self, name, age):
        self.name = name  # self.name is an instance attribute
        self.age = age

    # Instance method
    def bark(self):
        return "Woof!"

    def describe(self):
        return f"{self.name} is {self.age} years old."

print(my_dog.describe())
# Output: Buddy is 5 years old.
print(your_dog.describe())
# Output: Lucy is 3 years old.
```

**Key Components:**
- **`__init__` method:** This special method is called the "constructor." It's executed when you create a new object of the class. It's used to initialize the object's attributes.
- **`self`:** The `self` parameter is a reference to the current instance of the class. It is used to access variables that belong to the class. It must be the first parameter of any method in the class.
- **Attributes:** `name` and `age` are instance attributes, specific to each `Dog` object. `species` is a class attribute, shared by all `Dog` objects.
- **Methods:** `bark()` and `describe()` are instance methods, which are functions defined inside a class that can be called on an object.

### Creating an Instance (Object)

To create an object from a class, you "call" the class like a function.

```python
# Create two Dog objects
my_dog = Dog("Buddy", 5)
your_dog = Dog("Lucy", 3)

# Accessing attributes
print(my_dog.name)   # Output: Buddy
print(your_dog.age)    # Output: 3

# Calling methods
print(my_dog.bark())     # Output: Woof!
print(your_dog.describe()) # Output: Lucy is 3 years old.
```

### A different example

```python
class Circle:
    pi = 3.14

    # Circle gets instantiated with a radius (default is 1)
    def __init__(self, radius=1):
        self.radius = radius 
        self.area = radius * radius * Circle.pi

    # Method for getting Circumference
    def getCircumference(self):
        return self.radius * self.pi * 2

    # Method for resetting Radius
    def setRadius(self, new_radius):
        self.radius = new_radius
        self.area = new_radius * new_radius * self.pi


c = Circle()

print('Radius is: ',c.radius)
print('Area is: ',c.area)
print('Circumference is: ',c.getCircumference())

# Output: 
# Radius is:  1
# Area is:  3.14
# Circumference is:  6.28

c.setRadius(2)

print('Radius is: ',c.radius)
print('Area is: ',c.area)
print('Circumference is: ',c.getCircumference())

# Output: 
# Radius is:  2
# Area is:  12.56
# Circumference is:  12.56
```

## Inheritance

Inheritance is a mechanism that allows a new class (the **child class** or **subclass**) to inherit attributes and methods from an existing class (the **parent class** or **superclass**). This promotes code reuse.

**Example:** Let's create a `GoldenRetriever` class that inherits from `Dog`.

```python
class GoldenRetriever(Dog):  # Inherits from Dog
    def fetch(self, item):
        return f"{self.name} is fetching the {item}!"
```

The `GoldenRetriever` class automatically has all the attributes and methods of the `Dog` class, plus its own new `fetch` method.

```python
retriever = GoldenRetriever("Goldie", 2)
print(retriever.describe())  # Method from parent class
print(retriever.fetch("ball")) # Method from child class

# Output:
# Goldie is 2 years old.
# Goldie is fetching the ball!
```

You can also **override** parent methods by defining a method with the same name in the child class.

```python
class Chihuahua(Dog):   # Inherits from Dog
    def bark(self):     # Overrides the bark method from the parent class
        return "Yip!"

chihuahua = Chihuahua("Chico", 1)
print(chihuahua.bark())
# Output: Yip!
```

## Polymorphism

Polymorphism means "many forms." In programming, it refers to the ability of different objects to respond to the same method call in different ways.

**Example:** Let's say we have a `Cat` class and a `Dog` class, both with a `speak` method.

```python
class Cat:
    def speak(self):
        return "Meow!"

class Dog:
    def speak(self):
        return "Woof!"

# A function that can work with any animal that can "speak"
def animal_sound(animal):
    print(animal.speak())

my_dog = Dog()
my_cat = Cat()

animal_sound(my_dog)  # Output: Woof!
animal_sound(my_cat)  # Output: Meow!
```

Here, the `animal_sound` function doesn't need to know if the object is a `Dog` or a `Cat`. It just calls the `speak()` method, and the object itself knows how to respond correctly. This makes the code more flexible and extensible.

## Encapsulation

Encapsulation is the bundling of data (attributes) and methods that operate on the data into a single unit (a class). It also involves restricting direct access to some of an object's components, which is a way to prevent the accidental modification of data.

In Python, there is no strict "private" keyword like in some other languages. However, by convention, we can indicate that an attribute is intended for internal use by prefixing its name with an underscore (`_`).

**Example:**

```python
class Car:
    def __init__(self, make, model):
        self.make = make          # Public attribute
        self._model = model       # "Protected" attribute
        self.__speed = 0          # "Private" attribute (name mangling)

    def accelerate(self):
        self.__speed += 10

    def get_speed(self):
        return self.__speed

my_car = Car("Toyota", "Corolla")
print(my_car.make)  # Output: Toyota
print(my_car._model) # Output: Corolla
print(my_car.__speed) # Output: AttributeError: 'Car' object has no attribute '__speed'
print(my_car._Car__speed) # Output: 0
my_car.accelerate()
print(my_car.get_speed()) # Output: 10
```

- **`make`:** Publicly accessible.
- **`_model`:** Convention says you shouldn't access this directly from outside the class.
- **`__speed`:** Two underscores cause "name mangling." Python changes the name to `_Car__speed`, making it harder to access from outside.

This principle helps in creating a clear interface for your objects and preventing unintended changes to their internal state.

## Special Methods

Special methods are a set of predefined methods that allow you to use objects in a more natural way. They are called when you use certain built-in functions and operators on objects.

```python
class Book:
    def __init__(self, title, author, pages):
        print("A book is created")
        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self):
        return f"Title: {self.title}, Author: {self.author}, Pages: {self.pages}"

    def __len__(self):
        return self.pages

    def __del__(self):
        print("A book is destroyed")

my_book = Book("The Great Gatsby", "F. Scott Fitzgerald", 180)
print(my_book)
# Output: Title: The Great Gatsby, Author: F. Scott Fitzgerald, Pages: 180
print(len(my_book))
# Output: 180
del my_book
# Output: A book is destroyed
print(my_book)
# Output: NameError: name 'my_book' is not defined
```

**Exercise**: Create a Line class that has a start point and an end point. The class should have a method to calculate the length and slope of the line.
**Exercise**: Create a Rectangle class that has a width and height. The class should have a method to calculate the area and perimeter of the rectangle.
**Exercise**: Create a Cylinder class that has a radius and height. The class should have a method to calculate the volume and surface area of the cylinder.
**Exercise**: Create a BankAccount class that has an owner and balance attributes and methods to deposit and withdraw money. The class should keep track of the balance and prevent withdrawals that exceed the balance.

## Data Classes

Introduced in Python 3.7, data classes are a way to automatically add special methods like `__init__()`, `__repr__()`, and `__eq__()` to your classes. They are great for classes that primarily store data.

You use the `@dataclass` decorator.

**Before Data Classes:**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

    def __eq__(self, other):
        return self.name == other.name and self.age == other.age
```

**With Data Classes:**

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

p1 = Person("Alice", 30)
p2 = Person("Alice", 30)

print(p1)       # Output: Person(name='Alice', age=30)
print(p1 == p2) # Output: True
```

As you can see, the data class version is much more concise and provides useful default behaviors without writing boilerplate code.
