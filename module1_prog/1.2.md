# 1.2: Data Structures and Control Flow

## Introduction to Data Structures

Data structures are a way of organizing and storing data in a computer so that it can be accessed and used efficiently. Python has several built-in data structures, and in this section, we will focus on lists and tuples.

## Lists

A list is an ordered and **mutable** (changeable) collection of items. Lists can contain items of different data types.

### Creating Lists

You create a list by placing items inside square brackets `[]`, separated by commas.

```python
# A list of integers
numbers = [1, 2, 3, 4, 5]

# A list of strings
fruits = ["apple", "banana", "cherry"]

# A list with mixed data types
mixed_list = ["hello", 3.14, True, 42]
```

### List Membership

You can check if an item is in a list using the `in` operator.

```python
"apple" in fruits # Output: True
"pineapple" in fruits # Output: False
```

You can also check if an item is not in a list using the `not in` operator.

```python
"apple" not in fruits # Output: False
"pineapple" not in fruits # Output: True
```

### Indexing and Slicing

You can access elements in lists and other sequence types (like strings and tuples) using indexing and slicing.

*   **Indexing:** Access individual items using their index. Python is zero-indexed, meaning the first item is at index 0.

    ```python
    fruits = ["apple", "banana", "cherry"]
    print(fruits[0])  # Output: apple
    print(fruits[2])  # Output: cherry
    ```

*   **Negative Indexing:** You can also use negative indices to access items from the end of the list. `-1` refers to the last item, `-2` to the second-to-last, and so on.

    ```python
    print(fruits[-1]) # Output: cherry
    print(fruits[-2]) # Output: banana
    ```

*   **Slicing:** Access a range of items by specifying a `start` and `end` index (`start:end`). The slice will include the element at the `start` index but **exclude** the element at the `end` index.

    ```python
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(numbers[1:5])  # Output: [1, 2, 3, 4]
    print(numbers[:4])   # Output: [0, 1, 2, 3] (from the beginning up to index 4)
    print(numbers[5:])   # Output: [5, 6, 7, 8, 9] (from index 5 to the end)
    ```

*   **Slicing with a Step:** You can also provide a "step" value to your slice (`start:end:step`). This allows you to skip elements.

    ```python
    print(numbers[0:10:2]) # Output: [0, 2, 4, 6, 8] (every second element)
    ```

*   **Reversing a List with Slicing:** A common trick is to use a step of `-1` to reverse a list.

    ```python
    print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
    ```


### Modifying Lists

Since lists are mutable, you can change their content.

*   **Change an item:**
    ```python
    fruits[1] = "blueberry"
    print(fruits)  # Output: ['apple', 'blueberry', 'cherry']
    ```
*   **Change multiple items:**
    ```python
    fruits[1:3] = ["blueberry", "grape"]
    print(fruits)  # Output: ['apple', 'blueberry', 'grape']
    ```
*   **Delete an item:**
    ```python
    del fruits[1]
    print(fruits)  # Output: ['apple', 'grape', 'cherry']
    ```
*   **Delete multiple items:**
    ```python
    del fruits[1:3]
    print(fruits)  # Output: ['apple', 'cherry']
    ```
*   **List concatenation:**
    ```python
    fruits1 = ["apple", "banana", "cherry"]
    fruits2 = ["orange", "mango", "pineapple"]
    fruits = fruits1 + fruits2
    print(fruits)  # Output: ['apple', 'banana', 'cherry', 'orange', 'mango', 'pineapple']
    ```
*   **List repetition:**
    ```python
    fruits = ["apple"] * 3
    print(fruits)  # Output: ['apple', 'apple', 'apple']
    ```

### List Methods

| Method | Description |
| :----- | :---------- |
| `.append(item)` | Adds an item to the end of the list. |
| `.insert(index, item)` | Adds an item at a specified index. |
| `.extend(items)` | Adds multiple items to the end of the list. |
| `.remove(item)` | Removes the first occurrence of a specified value. |
| `.pop(index)` | Removes an item at a specified index (or the last item if the index is not provided). |
| `.clear()` | Removes all items from the list. |
| `.sort()` | Sorts the list in ascending order. |
| `.reverse()` | Reverses the list. |
| `.copy()` | Returns a copy of the list. |
| `.count(item)` | Returns the number of occurrences of a specified value. |
| `.index(item)` | Returns the index of the first occurrence of a specified value. |

#### Examples:
*   `append()`: Adds an item to the end of the list.
    ```python
    fruits.append("orange")
    print(fruits) # Output: [...existing items..., 'orange']
    ```
*   `insert()`: Adds an item at a specified index.
    ```python
    fruits.insert(1, "grape")
    print(fruits) # Output: [...existing items..., 'grape', ...existing items...]
    ```
*   `extend()`: Adds multiple items to the end of the list.
    ```python
    fruits.extend(["mango", "pineapple"])
    print(fruits) # Output: [...existing items..., 'mango', 'pineapple']
    ```
*   `remove()`: Removes the first occurrence of a specified value.
    ```python
    fruits.remove("cherry")
    ```

> **Note**: `.remove()` vs `del`.
> * `.remove()` removes the first occurrence of a specified value.
> * `del` removes the item at a specified index.


*   `pop()`: Removes an item at a specified index (or the last item if the index is not provided).
    ```python
    fruits.pop(1)
    ```

> **Note**: 
> `len()` is a function that returns the length of the list.
> ```python
> fruits = ["apple", "banana", "cherry"]
> len(fruits) # Output: 3
> ```

### Nested Lists

A nested list is a list that contains other lists as its elements.

```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list[0]) # Output: [1, 2, 3]
print(nested_list[0][1]) # Output: 2
```

> **Note**: `zip` function can be used to combine multiple lists into a single list of tuples.
> ```python
> list1 = [1, 2, 3]
> list2 = ['a', 'b', 'c']
> list3 = ['X', 'Y', 'Z']
> zipped = zip(list1, list2, list3)
> print(zipped) # Output: [(1, 'a', 'X'), (2, 'b', 'Y'), (3, 'c', 'Z')]
> ```

## Tuples

A tuple is an ordered and **immutable** (unchangeable) collection of items. Once a tuple is created, you cannot change its values.

### Creating Tuples

You create a tuple by placing items inside parentheses `()`, separated by commas.

```python
# A tuple of numbers
point = (10, 20)

# A tuple of strings
colors = ("red", "green", "blue")
```

### When to use Tuples?

Use tuples when you have data that should not change, such as coordinates, dates, or configuration settings. Their immutability makes your code safer from accidental changes.

> **Note**: Tuple indexing, slicing, and membership testing are the same as list indexing, slicing, and membership testing. The only difference is that tuples are immutable, so you cannot change their values.

## Variable Assignment Behavior

When you assign a value to a variable, you are actually creating a reference to the object in memory.

```python
x = 10
y = x
print(x) # Output: 10
print(y) # Output: 10
print(x is y) # Output: True
```

For immutable objects, `int`, `float`, `str`, `bool`, `tuple`, etc., changing the value of one variable will not affect the value of the other variable in general.

```python
x = 10
y = x
y = 20 # This will create a new object in memory and assign it to y
print(x) # Output: 10
print(y) # Output: 20
print(x is y) # Output: False
```

For mutable objects, `list`, `dict`, `set`, etc., changing the value of one variable will affect the value of the other variable.

```python
x = [1, 2, 3]
y = x
y.append(4) # This will change the value of the list in memory
print(x) # Output: [1, 2, 3, 4]
print(y) # Output: [1, 2, 3, 4]
print(x is y) # Output: True
```

Note that even when you are dealing with mutable objects, if you assign a new value to y, it will create a new object in memory and assign it to y.
```python
x = [1, 2, 3]
y = x
y = ['a', 'b', 'c'] # This will create a new object in memory and assign it to y
print(x) # Output: [1, 2, 3]
print(y) # Output: ['a', 'b', 'c']
print(x is y) # Output: False
```

> **Note**: If you want the two variables to stay independent for mutable objects, make a copy:
> ```python
> x = [1, 2, 3]
> y = x.copy()
> y.append(4) # This will create a new object in memory and assign it to y
> print(x) # Output: [1, 2, 3]
> print(y) # Output: [1, 2, 3, 4]
> print(x is y) # Output: False
> ```
> For nested objects, you can use the `copy.deepcopy()` function to create a deep copy of the object.
> ```python
> import copy
> x = [[1, 2, 3], [4, 5, 6]]
> y = copy.deepcopy(x) # This will create a deep copy of the object which is independent of the original object
> y[0][0] = 10
> print(x) # Output: [[1, 2, 3], [4, 5, 6]]
> print(y) # Output: [[10, 2, 3], [4, 5, 6]]
> print(x is y) # Output: False
> ```

## Logical Operators

Logical operators in the order of precedence:

| Operator | Description |
| :------- | :---------- |
| `not` | Returns the opposite of the operand. (highest precedence) |
| `and` | Returns `True` if both operands are `True`. |
| `or` | Returns `True` if at least one operand is `True`. (lowest precedence) |

```python
print(True and True) # Output: True
print(True or False) # Output: True
print(not True) # Output: False
print(not False) # Output: True
```

> **Note**: `and` has higher precedence than `or`.
> ```python
> print(True and False or True) # Output: True
> print(True and (False or True)) # Output: True
> print(True and True and False) # Output: False
> ```

### Chained Comparison Operators

You can chain multiple comparison operators to check if a value is within a range.

```python
1 < 5 < 10 # Output: True
1 < 5 and 5 < 10 # Output: True

1 < 5 < 3 # Output: False
1 < 5 and 5 < 3 # Output: False

1 < 3 > 2 # Output: True
1 < 3 and 3 > 2 # Output: True
```

## Conditional Statements

Conditional statements allow you to execute certain blocks of code based on whether a condition is true or false.

### `if`, `elif`, and `else`

*   `if`: The block of code under `if` is executed if the condition is `True`.
*   `elif` (else if): If the first `if` condition is `False`, Python checks the `elif` condition.
*   `else`: If all preceding conditions are `False`, the `else` block is executed.

> **Note on indentation**:
> The code block under `if`, `elif`, and `else` is indented. This is how Python knows which code block to execute.
> ```python
> if condition:
>     # code block
> elif condition:
>     # code block
> else:
>     # code block
> ```

```python
age = 18

if age < 13:
    print("You are a child.")
elif age < 20:
    print("You are a teenager.")
else:
    print("You are an adult.")
# Output: You are a teenager.
```

### Nested Conditional Statements

You can nest conditional statements inside other conditional statements.

```python
if condition1:
    if condition2:
        # code block
    else:
        # code block
elif condition3:
    # code block
else:
    # code block
```

**Example**:
```python
if age < 13:
    if age < 2:
        print("You are a baby.")
    elif age < 7:
        print("You are a toddler.")
    else:
        print("You are a kid.")
elif age < 20:
    print("You are a teenager.")
else:
    print("You are an adult.")
```

### Single-line Conditional Statements

You can write a single-line conditional statement using the `if` keyword.
```python
x = 10
if x > 5: print("x is greater than 5") # Output: x is greater than 5

a = 100 if x > 5 else 0
print(a) # Output: 100
```

### Match Statement

**Note**: There is a `match` statement starting from Python 3.10, which is a more powerful and flexible way to write conditional statements.
```python
match variable:
    case value1:
        # code block
    case value2:
        # code block
    case _: # (optional) default case
        # code block to be executed if no other case is matched
```

**Example**:
```python
day = 4
match day:
    case 1:
        print("Monday")
    case 2:
        print("Tuesday")
    case 3:
        print("Wednesday")
    case 4:
        print("Thursday")
    case 5:
        print("Friday")
    case 6 | 7: # pipe (`|`) is the or operator
        print("Weekend")
    case _:
        print("Unknown day")
```

## Loops

Loops are used to execute a block of code repeatedly; it goes through a sequence of items one by one.

### `for` Loops

General syntax:
```python
for item in sequence:
    # code block
```

A `for` loop is used for iterating over a sequence (like a list, tuple, or string).

```python
# Looping through a list of numbers
numbers = [0, 1, 2, 3, 4]
for i in numbers:
    print(i)
# Output: 0, 1, 2, 3, 4

# Looping through a range of numbers (0 to 4)
for i in range(5):  # range(5) generates numbers from 0 to 4 (5 is not included)
    print(i)
# Output: 0, 1, 2, 3, 4

# Looping through a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# Looping through a list of tuples
points = [(1, 'a'), (2, 'b'), (3, 'c')]
for n, s in points:
    print(n, s)
# Output: 1 a, 2 b, 3 c
```

> **Note**: `enumerate()` is a built-in function that returns an enumerate object. The enumerate object is an iterator that returns a tuple containing a count (from start which defaults to 0) and the value obtained from iterating over the sequence.
> ```python
> # Looping with enumerate()
> for index, item in enumerate(fruits):
>     print(index, item)
> # Output: 0 apple, 1 banana, 2 cherry
> ```

> **Note**: The variable `i` is a counter variable that is used to iterate over the sequence. It is not a special variable, you can use any variable name you want.

### `while` Loops

A `while` loop executes a block of code as long as a specified condition is `True`.

General syntax:
```python
while condition:
    # code block
else:
    # code block (optional)
```

> **Note**: The `else` block is optional. It will be executed if the condition is `False`, i.e. after the loop is finished.

It will keep executing the block of code until the condition is `False`.

```python
count = 0
while count < 5:
    print('count is currently: ', count)
    count += 1  # It's crucial to have a way to exit the loop!
# Output: 
# count is currently: 0
# count is currently: 1
# count is currently: 2
# count is currently: 3
# count is currently: 4
```

### `break`, `continue`, `pass`

*   `break`: Breaks out of the current loop.
*   `continue`: Skips the rest of the code in the current loop and goes to the next iteration.
*   `pass`: Does nothing. It is used as a placeholder when you don't want to execute any code.

```python
# example of pass
for i in range(10):
    pass # Does nothing

# example of break
for i in range(10):
    if i == 3:
        break # Breaks out of the loop
    print(i)
# Output: 0, 1, 2

# example of continue
for i in range(10):
    if i == 3:
        continue # Skips 3
    print(i)
# Output: 0, 1, 2, 4, 5, 6, 7, 8, 9

# example of break and continue
for i in range(10):
    if i == 7:
        break # Breaks out of the loop after 7
    if i == 3:
        continue # Skips 3
    print(i)
# Output: 0, 1, 2, 4, 5, 6
```

### Nested Loops

You can nest loops inside other loops.

```python
for i in ["apple", "banana", "cherry"]:
    for j in [1, 2, 3]:
        print(i, j)
# Output: apple 1, apple 2, apple 3, banana 1, banana 2, banana 3, cherry 1, cherry 2, cherry 3
```

## List Comprehensions

List comprehensions provide a concise and readable way to create lists. They are often more performant than using a standard `for` loop and `.append()`.

### The Basic Syntax

The simplest form of a list comprehension is:

```python
[expression for item in iterable]
```

This is the equivalent of the following `for` loop:

```python
new_list = []
for item in iterable:
    new_list.append(expression)
```

**Example**

*With a `for` loop:*
```python
squares = []
for x in range(1, 6):
    squares.append(x**2)
print(squares) # Output: [1, 4, 9, 16, 25]
```

*With a list comprehension:*
```python
squares = [x**2 for x in range(1, 6)]
print(squares) # Output: [1, 4, 9, 16, 25]
```

### Adding a Condition

You can add a conditional filter to a list comprehension.

```python
[expression for item in iterable if condition]
```

This is equivalent to:
```python
new_list = []
for item in iterable:
    if condition:
        new_list.append(expression)
```

**Example**

*With a `for` loop:*
```python
numbers = [1, 2, 3, 4, 5, 6]
evens = []
for num in numbers:
    if num % 2 == 0:
        evens.append(num)
print(evens) # Output: [2, 4, 6]
```

*With a list comprehension:*
```python
numbers = [1, 2, 3, 4, 5, 6]
evens = [num for num in numbers if num % 2 == 0]
print(evens) # Output: [2, 4, 6]
```

### `if-else` in List Comprehensions

If you need to perform a different action based on the condition (like an `if-else` block), the syntax changes slightly. The `if-else` block comes *before* the `for` loop.

```python
[expression_if_true if condition else expression_if_false for item in iterable]
```

**Example**

*With a `for` loop:*
```python
numbers = [1, 2, 3, 4, 5, 6]
labels = []
for num in numbers:
    if num % 2 == 0:
        labels.append("even")
    else:
        labels.append("odd")
print(labels) # Output: ['odd', 'even', 'odd', 'even', 'odd', 'even']
```

*With a list comprehension:*
```python
numbers = [1, 2, 3, 4, 5, 6]
labels = ["even" if num % 2 == 0 else "odd" for num in numbers]
print(labels) # Output: ['odd', 'even', 'odd', 'even', 'odd', 'even']
```

### Nested List Comprehensions

List comprehensions can be nested to work with nested lists (like a matrix or list of lists).

**Example**

*With nested `for` loops:*
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat_list = []
for row in matrix:
    for num in row:
        flat_list.append(num)
print(flat_list) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

*With a nested list comprehension:*
The `for` clauses are in the same order as they would be in the nested loop.
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat_list = [num for row in matrix for num in row]
print(flat_list) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```
> **Note**: While powerful, nested list comprehensions can sometimes be harder to read than the equivalent nested `for` loops. Choose the option that is most clear for your use case.