# 2.1 Numerical Computing with NumPy

## Introduction to NumPy

NumPy, which stands for **Numerical Python**, is a fundamental library for numerical computing in Python. It provides a powerful data structure called the **NumPy array** (or `ndarray`, i.e. N-dimensional array), which is a multi-dimensional array object. NumPy arrays are more efficient than Python lists for numerical operations, both in terms of storage and execution speed.

Key features of NumPy include:

*   **Efficient N-dimensional array object:** The `ndarray` is a fast and flexible container for large datasets in Python.
*   **Broadcasting functions:** NumPy allows for operations between arrays of different sizes, a concept known as broadcasting.
*   **Tools for integrating C/C++ and Fortran code:** NumPy provides tools to integrate with code written in other languages.
*   **Useful linear algebra, Fourier transform, and random number capabilities:** NumPy has a rich set of functions for a wide range of mathematical operations.

To get started with NumPy, you first need to install numpy and then import it. 
```pip install numpy```
The standard convention is to import it with the alias `np`:
```python
import numpy as np
```

## NumPy Arrays (ndarrays)

The core of NumPy is the `ndarray` object. These arrays are homogeneous, meaning they can only contain elements of the same data type. This is a key difference from Python lists, which can hold elements of different types.

### Creating NumPy Arrays

You can create NumPy arrays in several ways. The most common method is to create them from Python lists or tuples using the `np.array()` function.

**Example: Creating a 1D array**

```python
# Create a 1D array from a list
my_list = [1, 2, 3, 4, 5]
my_array = np.array(my_list)

print(my_array)
# Output: [1 2 3 4 5]

print(type(my_array))
# Output: <class 'numpy.ndarray'>
```

**Example: Creating a 2D array (matrix)**

```python
# Create a 2D array from a list of lists
my_2d_list = [[1, 2, 3], [4, 5, 6]]
my_2d_array = np.array(my_2d_list)

print(my_2d_array)
# Output:
# [[1 2 3]
#  [4 5 6]]
```

NumPy also provides several functions to create arrays with initial placeholder content:

*   `np.zeros()`: Creates an array filled with zeros.
*   `np.ones()`: Creates an array filled with ones.
*   `np.empty()`: Creates an array with a specified shape and fills it with random values (not initialized).
*   `np.full()`: Creates an array filled with a specific value.
*   `np.arange()`: Creates an array with a range of numbers.
*   `np.linspace()`: Creates an array with a specified number of elements, spaced equally between two values.
*   `np.random.rand()`: Creates an array of a given shape and populates it with random samples from a uniform distribution over `[0, 1)`.

**Examples:**

```python
# Create a 1D array of 5 zeros
zeros_array = np.zeros(5)
print(zeros_array)
# Output: [0. 0. 0. 0. 0.]

# Create a 2x3 array of ones
ones_array = np.ones((2, 3))
print(ones_array)
# Output:
# [[1. 1. 1.]
#  [1. 1. 1.]]

# Create a 2x3 array filled with random values (not initialized)
empty_array = np.empty((2, 3))
print(empty_array)
# Output:
# [[0.12345678 0.87654321 0.45678901]
#  [0.98765432 0.23456789 0.56789012]]

# Create a 2x3 array filled with 5
full_array = np.full((2, 3), 5)
print(full_array)
# Output:
# [[5 5 5]
#  [5 5 5]]

# Create an array with numbers from 0 to 9
range_array = np.arange(10)
print(range_array)
# Output: [0 1 2 3 4 5 6 7 8 9]

# Create an array of 5 numbers evenly spaced between 0 and 1
linspace_array = np.linspace(0, 1, 5)
print(linspace_array)
# Output: [0.   0.25 0.5  0.75 1.  ]

# Create a 2x3 array of random numbers
random_array = np.random.rand(2, 3)
print(random_array)
# Output:
# [[0.12345678 0.87654321 0.45678901]
#  [0.98765432 0.23456789 0.56789012]]
```

```python
# TODO: Explain the theory behind the distributions (uniform, normal, etc.) and show examples of different types of random distributions in the `np.random` module. Include plots. See tools_numpy notebook. To be done in Data Science chapter.
```

### Array Attributes

NumPy arrays have several important attributes that provide information about the array.

*   `ndarray.ndim`: The number of dimensions (or axes) of the array.
*   `ndarray.shape`: A tuple of integers indicating the size of the array in each dimension.
*   `ndarray.size`: The total number of elements in the array.
*   `ndarray.dtype`: An object describing the data type of the array's elements.

**Example:**

```python
# Create a 2D array
my_2d_array = np.array([[1, 2, 3], [4, 5, 6]])

print("Shape of the array:", my_2d_array.shape)
# Output: Shape of the array: (2, 3)

print("Number of dimensions:", my_2d_array.ndim)
# Output: Number of dimensions: 2

print("Size of the array:", my_2d_array.size)
# Output: Size of the array: 6

print("Data type of the array:", my_2d_array.dtype)
# Output: Data type of the array: int32

print("Flattened array:", my_2d_array.flatten())
# Output: Flattened array: [1 2 3 4 5 6]
```

> **Note:** When you iterate over the multi-dimensional array, 
> ```python
> my_2d_array = np.array([[1, 2, 3], [4, 5, 6]])
> 
> for m in my_2d_array:
>     print("Item:")
>     print(m)
> 
> # Output:
> # Item:
> # [1 2 3]
> # Item:
> # [4 5 6]
> 
> for m in my_2d_array.flat:
>     print("Item:")
>     print(m)
> 
> # Output:
> # Item:
> # 1
> # Item:
> # 2
> # Item:
> # 3
> # Item:
> # 4
> # Item:
> # 5
> # Item:
> # 6
> ```

### Reshaping Arrays

You can reshape an array using the `reshape()` method.

**Example:**

```python
my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(my_array.reshape(2, 5))
# Output: 
# [[0 1 2 3 4]
#  [5 6 7 8 9]]
```

### Data Types

Instead of letting NumPy infer the data type from the elements in the array, you can explicitly specify the data type using the `dtype` parameter in the `np.array()` function.

**Example:**

```python
my_array = np.array([1, 2, 3], dtype=np.float32)
print(my_array.dtype, "|", my_array)
# Output: float32 | [1. 2. 3.]

my_array = np.array([1, 2, 3], dtype=np.complex64)
print(my_array.dtype, "|", my_array)
# Output: complex64 | [1.+0.j 2.+0.j 3.+0.j]
```

Available data types include signed integers (`int8`, `int16`, `int32`, `int64`), unsigned integers (`uint8`, `uint16`, `uint32`, `uint64`), floating-point numbers (`float16`, `float32`, `float64`), and complex numbers (`complex64`, `complex128`).


### Array from Functions

You can create arrays from functions using the `np.fromfunction()` function, which takes a function and a shape as arguments and returns a new array. The value of the array at position `(x,y,z,...)` is the result of the function applied to `(x,y,z,...)`.

**Example:**

```python
# Create a 2D array from a function
def my_function(i, j):
    return i + j
my_2d_array = np.fromfunction(my_function, (3, 3))
print(my_2d_array)
# Output:
# [[0. 1. 2.]
#  [1. 2. 3.]
#  [2. 3. 4.]]
```

**Alternative Syntax:**

You can also use a lambda function to create the array.

```python
my_2d_array = np.fromfunction(lambda i, j: i + j, (3, 3))
print(my_2d_array)
# Output:
# [[0. 1. 2.]
#  [1. 2. 3.]
#  [2. 3. 4.]]
```


## Array Indexing and Slicing

Indexing and slicing in NumPy are similar to Python lists, but with more powerful capabilities, especially for multi-dimensional arrays.

### 1D Array Indexing and Slicing

For 1D arrays, indexing and slicing work just like with Python lists.

**Example:**

```python
my_array = np.arange(10)

# Get the first element
print(my_array[0])
# Output: 0

# Get the last element
print(my_array[-1])
# Output: 9

# Get a slice from index 2 to 5 (exclusive)
print(my_array[2:5])
# Output: [2 3 4]

# Get a slice from the beginning to index 5 (exclusive)
print(my_array[:5])
# Output: [0 1 2 3 4]

# Get a slice from index 5 to the end
print(my_array[5:])
# Output: [5 6 7 8 9]

# Get every other element
print(my_array[::2])
# Output: [0 2 4 6 8]

# Get every other element in reverse
print(my_array[::-2])
# Output: [9 7 5 3 1]

# Get elements at specific indices
print(my_array[[0, 2, 4, -1, -2, -3, 2]])
# Output: [0 2 4 9 8 7 2]
```

Once you know the indices you can also modify them
```python
my_array[0] = 10
print(my_array)
# Output: [10 1 2 3 4 5 6 7 8 9]

my_array[2:5] = [100, 200, 300]
print(my_array)
# Output: [10 1 100 200 300 5 6 7 8 9]
```

> **Note:** You can shrink or grow the Python list by assigning a shorter or longer list to the slice.
> ```python
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = [100]
> print(my_list)
> # Output: [0, 1, 100, 5, 6, 7, 8, 9]
> 
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = [100, 200, 300, 400, 500]
> print(my_list)
> # Output: [0, 1, 100, 200, 300, 400, 500, 5, 6, 7, 8, 9]
> ```
> 
> Assigning a single value to a Python list will not work and will raise a TypeError.
> 
> ```python
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = 100
> print(my_list)
> # Output: TypeError: can only assign an iterable
> ```
> 
> In contrast, assigning a single value to a NumPy array will work.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = 100
> print(my_array)
> # Output: [0, 1, 100, 100, 100, 5, 6, 7, 8, 9]
> ```
> 
> But you cannot grow the array by assigning a longer list to the slice, you will get a ValueError.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = [100]
> print(my_array)
> # Output: ValueError: could not broadcast input array from shape (5,) into shape (3,)
> ```
> 
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = [100, 200, 300, 400, 500]
> print(my_array)
> # Output: [0, 1, 100, 200, 300, 400, 500, 5, 6, 7, 8, 9]
> ```
> Or you cannot delete a slice of the array, you will get a ValueError.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> del my_array[2:5]
> print(my_array)
> # Output: ValueError: cannot delete array elements
> ```

Similar to Python lists, modifying an element of the slice will modify the original array.

```python
my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
my_slice = my_array[2:5]
my_slice[1] = 1000
print(my_array)
# Output: [0, 1, 2, 1000, 4, 5, 6, 7, 8, 9]
```

If you want a copy of the data, you can use the `copy()` method.
```python
my_slice = my_array[2:5].copy()
my_slice[1] = 1000
print(my_array)
# Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(my_slice)
# Output: [2, 1000, 4]
```

### 2D Array Indexing and Slicing

For 2D arrays, you can use a comma-separated tuple of indices to access elements.

**Example:**

```python
my_2d_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Get the element at row 1, column 2
print(my_2d_array[1, 2])
# Output: 6

# You can also use the syntax my_2d_array[1][2]
print(my_2d_array[1][2])
# Output: 6
```

Slicing 2D arrays allows you to select sub-arrays.

**Example:**

```python
# Get the first two rows
print(my_2d_array[:2])
# Output:
# [[1 2 3]
#  [4 5 6]]

# Get the first two rows and all columns
print(my_2d_array[:2, :])
# Output:
# [[1 2 3]
#  [4 5 6]]

# Get all rows and the first two columns
print(my_2d_array[:, :2])
# Output:
# [[1 2]
#  [4 5]
#  [7 8]]

# Get a sub-array from the first two rows and columns 1 to the end
print(my_2d_array[:2, 1:])
# Output:
# [[2 3]
#  [5 6]]

# Get a sub-array from row 1 to row 3 (exclusive) and columns 1 to the end
print(my_2d_array[1:3, 1:])
# Output:
# [[5 6]
#  [8 9]]

# Get a sub-array from rows 0 and 2 (inclusive) and columns 2 to the end
print(my_2d_array[[0, 2], 2:])
# Output:
# [[3]
#  [9]]

# Get a sub-array from rows 0 and 2 (inclusive) and columns 2 to the end
print(my_2d_array[[0, 2, 1, 1], 2:])
# Output:
# [[3]
#  [9]
#  [6]
#  [6]]
```

### Ellipsis

**Example:**

```python
c = np.array([[[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11]],

       [[12, 13, 14, 15, 16, 17],
        [18, 19, 20, 21, 22, 23]],

       [[24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35]],

       [[36, 37, 38, 39, 40, 41],
        [42, 43, 44, 45, 46, 47]]])

print(c[2, 1, 4]) # matrix 2, row 1, col 4
# Output: 34

c[2, :, 3]  # matrix 2, all rows, col 3
# Output: [27 33]

c[2, 1]  # Return matrix 2, row 1, all columns.  This is equivalent to c[2, 1, :]
# Output: [30 31 32 33 34 35]
```

Ellipsis is a special constant that can be used to represent any number of dimensions. When you write ellipsis in the index, all non-specified dimensions are included.
```python
c[2, ...]  #  matrix 2, all rows, all columns.  This is equivalent to c[2, :, :]
# Output: 
# array([[24, 25, 26, 27, 28, 29],
#        [30, 31, 32, 33, 34, 35]])

c[2, 1, ...]  # matrix 2, row 1, all columns.  This is equivalent to c[2, 1, :]
# Output: array([30, 31, 32, 33, 34, 35])

c[2, ..., 3]  # matrix 2, all rows, column 3.  This is equivalent to c[2, :, 3]
# Output: array([27, 33])

c[..., 3]  # all matrices, all rows, column 3.  This is equivalent to c[:, :, 3]
# Output: 
# array([[ 3,  9],
#        [15, 21],
#        [27, 33],
#        [39, 45]])
```

### Boolean Indexing

Boolean indexing allows you to select elements from an array based on a condition.

**Example:**

```python
my_array = np.array([1, 2, 3, 4, 5, 6])

# Create a boolean array
bool_array = my_array > 3
print(bool_array)
# Output: [False False False  True  True  True]

# Use the boolean array to select elements
print(my_array[bool_array])
# Output: [4 5 6]

# You can also do this in one line
print(my_array[my_array > 3])
# Output: [4 5 6]
```

The same also works with multi-dimensional arrays.
```python
b = np.arange(48).reshape(4, 12)

rows_on = np.array([True, False, True, False])
b[rows_on, :]  # Rows 0 and 2, all columns. Equivalent to b[(0, 2), :]
# Output:
# array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],
#        [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]])
```

For multiple axes, you can use a tuple of indices, with `np.ix_` to generate the boolean indices for each axis.
```python
rows_on = np.array([True, False, True, False])
cols_on = np.array([False, True, False] * 4)
b[np.ix_(rows_on, cols_on)]
# Output:
# array([[ 1,  4,  7, 10],
#        [25, 28, 31, 34]])
```

## Array Operations

NumPy allows you to perform element-wise operations on arrays, which are very efficient.

### Vectorized Operations

Vectorized operations are operations that are applied to entire arrays at once, without the need for explicit loops.

**Example: Basic Arithmetic**

```python
array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])

# Element-wise addition
print(array1 + array2)
# Output: [5 7 9]

# Element-wise subtraction
print(array1 - array2)
# Output: [-3 -3 -3]

# Element-wise multiplication
print(array1 * array2)
# Output: [ 4 10 18]

# Element-wise division
print(array1 / array2)
# Output: [0.25 0.4  0.5 ]
```

You can also perform operations between an array and a scalar.

**Example: Operations with a Scalar**

```python
my_array = np.array([1, 2, 3])

# Add 10 to each element
print(my_array + 10)
# Output: [11 12 13]

# Multiply each element by 2
print(my_array * 2)
# Output: [2 4 6]

# Square each element
print(my_array ** 2)
# Output: [1 4 9]
```

### Broadcasting

Broadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes.

#### The Rules of Broadcasting

When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e., rightmost) dimensions and works its way left. Two dimensions are compatible when:

1.  they are equal, or
2.  one of them is 1.

If these conditions are not met, a `ValueError: operands could not be broadcast together` is thrown.

Let's break down the process:

1.  **Rule 1: Pad Dimensions**
    If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.

2.  **Rule 2: Stretch Dimensions**
    If the shape of the two arrays does not match in any dimension, the array with a shape equal to 1 in that dimension is stretched to match the other shape.

3.  **Rule 3: Raise Error**
    If in any dimension the sizes disagree and neither is equal to 1, an error is raised.

**Example 1: Broadcasting a 1D array across a 2D array**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
]) # Shape: (2, 3)

my_1d_array = np.array([10, 20, 30]) # Shape: (3,)
```

Let's apply the rules:
- **Shapes:** `my_2d_array` is `(2, 3)` and `my_1d_array` is `(3,)`.
- **Rule 1:** Pad the shape of `my_1d_array` to match the number of dimensions. It becomes `(1, 3)`.
- **Rule 2:** Compare dimensions right to left:
    - `3` vs `3`: They are equal.
    - `2` vs `1`: The `1` is stretched to match the `2`.
- The effective shape of `my_1d_array` becomes `(2, 3)`, and the addition can proceed.

```python
# Add the 1D array to each row of the 2D array
result = my_2d_array + my_1d_array

print(result)
# Output:
# [[11 22 33]
#  [14 25 36]]
```

**Example 2: Broadcasting a column vector**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
]) # Shape: (2, 3)

my_col_vector = np.array([
    [10], 
    [20]
]) # Shape: (2, 1)
```
Let's apply the rules:
- **Shapes:** `my_2d_array` is `(2, 3)` and `my_col_vector` is `(2, 1)`.
- **Rule 1:** Both have 2 dimensions, so no padding is needed.
- **Rule 2:** Compare dimensions right to left:
    - `3` vs `1`: The `1` is stretched to match the `3`.
    - `2` vs `2`: They are equal.
- The effective shape of `my_col_vector` becomes `(2, 3)`.

```python
# Add the column vector to each column of the 2D array
result = my_2d_array + my_col_vector

print(result)
# Output:
# [[11 12 13]
#  [24 25 26]]
```

### Stacking Arrays

Stacking arrays is the process of combining multiple arrays along a new axis.

**Example:**

```python
q1 = np.full((3,4), 1.0)
q2 = np.full((4,4), 2.0)
q3 = np.full((3,4), 3.0)

q4 = np.vstack((q1, q2, q3))
q4
# Output:
# array([[1., 1., 1., 1.],
#        [1., 1., 1., 1.],
#        [1., 1., 1., 1.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [3., 3., 3., 3.],
#        [3., 3., 3., 3.],
#        [3., 3., 3., 3.]])

q5 = np.hstack((q1, q3))
q5
# Output:
# array([[1., 1., 1., 1., 3., 3., 3., 3.],
#        [1., 1., 1., 1., 3., 3., 3., 3.],
#        [1., 1., 1., 1., 3., 3., 3., 3.]])
```

The `stack` function stacks arrays along a new axis. All arrays have to have the same shape.
```python
q8 = np.stack((q1, q3))
q8
# Output:
# array([[[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]],
# 
#        [[3., 3., 3., 3.],
#         [3., 3., 3., 3.],
#         [3., 3., 3., 3.]]])
```

There is also a convenience function called `concatenate` that can be used to stack arrays along a given axis.

#### Understanding the `axis` Parameter

The `axis` parameter tells NumPy which dimension to operate on. It can be confusing, but here’s an easy way to think about it for a 2D array (a matrix):

-   **`axis=0`**: This refers to the **first dimension**, which is the **rows**. When you operate along `axis=0`, you are performing an operation *down the rows*. For concatenation, this means you are stacking the arrays **vertically**, one on top of the other.
-   **`axis=1`**: This refers to the **second dimension**, which is the **columns**. When you operate along `axis=1`, you are performing an operation *across the columns*. For concatenation, this means you are stacking the arrays **horizontally**, side-by-side.

Think of the `axis` as the dimension that will be "glued" together. When you concatenate along an axis, the arrays must have the same shape in all other dimensions.

**Example with `concatenate`:**

Let's see how this works with two 2x2 arrays:

```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

# Concatenate along axis=0 (stacking vertically)
# The number of columns (axis=1) must match.
vertical_stack = np.concatenate((a, b), axis=0)
print("Vertical Stack (axis=0):\n", vertical_stack)
# Output:
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]

# Concatenate along axis=1 (stacking horizontally)
# The number of rows (axis=0) must match.
horizontal_stack = np.concatenate((a, b), axis=1)
print("\nHorizontal Stack (axis=1):\n", horizontal_stack)
# Output:
# [[1 2 5 6]
#  [3 4 7 8]]
```

Now, let's look at the original example from the `vstack` section:

```python
q7 = np.concatenate((q1, q2, q3), axis=0)
q7 # Equivalent to q4 (vertical stack)
```

### Splitting Arrays
Splitting is the opposite of stacking. It is the process of dividing an array into multiple sub-arrays.
```python
r = np.arange(24).reshape(6,4)
r
# Output:
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11],
#        [12, 13, 14, 15],
#        [16, 17, 18, 19],
#        [20, 21, 22, 23]])

r1, r2, r3 = np.vsplit(r, 3)
r4, r5 = np.hsplit(r, 2)
r6, r7 = np.split(r, 2, axis=1) # Equivalent to r4, r5
```

### Transposing Arrays
Transposing an array is the process of flipping it over its diagonal.
```python
r.T
# Output:
# array([[ 0,  4,  8, 12, 16, 20],
#        [ 1,  5,  9, 13, 17, 21],
#        [ 2,  6, 10, 14, 18, 22],
#        [ 3,  7, 11, 15, 19, 23]])

r.transpose((1, 0)) # Equivalent to r.T
# Output:
# array([[ 0,  4,  8, 12, 16, 20],
#        [ 1,  5,  9, 13, 17, 21],
#        [ 2,  6, 10, 14, 18, 22],
#        [ 3,  7, 11, 15, 19, 23]])
```

The `T` attribute has no effect on 1D arrays.
```python
r1 = np.array([1, 2, 3, 4])
r1.T
# Output: array([1, 2, 3, 4])
```

You need to use the `reshape` function to transpose a 1D array.
```python
r1 = np.array([1, 2, 3, 4])
r2 = r1.reshape(1, 4)
# Output:
# array([[1, 2, 3, 4]])
r2.reshape(4, 1)
# Output:
# array([[1],
#        [2],
#        [3],
#        [4]])
```

## Mathematical and Statistical Functions

NumPy provides a wide range of mathematical and statistical functions that can be applied to arrays.

**Example: Basic Functions**

```python
my_array = np.array([1, 4, 9, 16])

# Get the square root of each element
print(np.sqrt(my_array))
# Output: [1. 2. 3. 4.]

# Get the exponential of each element
print(np.exp(my_array))
# Output: [2.71828183e+00 5.45981500e+01 8.10308393e+03 8.88611052e+06]
```

**Example: Statistical Functions**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
])

# Get the sum of all elements
print(np.sum(my_2d_array))
# Output: 21

# Get the sum of elements along each column
print(np.sum(my_2d_array, axis=0))
# Output: [5 7 9]

# Get the sum of elements along each row
print(np.sum(my_2d_array, axis=1))
# Output: [ 6 15]

# Get the mean of all elements
print(np.mean(my_2d_array))
# Output: 3.5

# Get the standard deviation
print(np.std(my_2d_array))
# Output: 1.707825127659933
```

## Linear Algebra with NumPy

NumPy provides a `linalg` module that contains a rich set of functions for linear algebra operations.

**Example: Matrix Multiplication**

To perform matrix multiplication, you can use the `@` operator or the `np.dot()` function.

```python
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])

# Using the @ operator
result1 = matrix1 @ matrix2
print(result1)
# Output:
# [[19 22]
#  [43 50]]

# Using np.dot()
result2 = np.dot(matrix1, matrix2)
print(result2)
# Output:
# [[19 22]
#  [43 50]]
```

> **Note**: `matrix1 * matrix2` is not the same as `matrix1 @ matrix2`. It is element-wise multiplication also called "Hadamard product".
> ```python
> matrix1 = np.array([[1, 2], [3, 4]])
> matrix2 = np.array([[5, 6], [7, 8]])
> 
> # Using the * operator
> result3 = matrix1 * matrix2
> print(result3)
> # Output: [[ 5 12] [21 32]]
> ```

**Example: Inverse of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the inverse of the matrix
inverse_matrix = np.linalg.inv(my_matrix)

print(inverse_matrix)
# Output:
# [[-2.   1. ]
#  [ 1.5 -0.5]]

pseudo_inverse_matrix = np.linalg.pinv(my_matrix)

print(pseudo_inverse_matrix)
# Output:
# [[-2.   1. ]
#  [ 1.5 -0.5]]

np.allclose(my_matrix @ pseudo_inverse_matrix, np.eye(2))
# Output: True
```

**Note**: `np.linalg.pinv` is the pseudo-inverse of a matrix. It is a generalization of the inverse for non-square matrices. `np.allclose` is a function that checks if two matrices are close to each other within a specified tolerance. `np.eye(2)` creates a 2x2 identity matrix (matrix with ones on the diagonal and zeros elsewhere).

**Example: Determinant of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the determinant of the matrix
determinant = np.linalg.det(my_matrix)

print(determinant)
# Output: -2.0000000000000004
```

**Example: Diagonal of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the diagonal of the matrix
diagonal = np.diag(my_matrix)

print(diagonal)
# Output: [1 4]
```

### Solving a system of linear scalar equations
The `solve` function solves a system of linear scalar equations, such as:

* $2x + 6y = 6$
* $5x + 3y = -9$

```python
coeffs  = np.array([[2, 6], [5, 3]])
depvars = np.array([6, -9])
solution = linalg.solve(coeffs, depvars)
solution
# Output: array([-3.,  2.])

coeffs.dot(solution), depvars
# Output: (array([6., -9.]), array([6., -9.]))