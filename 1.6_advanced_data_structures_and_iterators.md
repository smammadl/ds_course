# 2.3: Advanced Data Structures and Iterators

## Args and Kwargs (`*args` and `**kwargs`)

In Python, `*args` and `**kwargs` are used to handle an arbitrary number of arguments in a function. This provides flexibility when you don't know in advance how many arguments will be passed to your function.

### `*args` (Arbitrary Positional Arguments)

The `*args` syntax allows a function to accept any number of positional arguments. These arguments are collected into a tuple.

**Think of it like this:** Imagine you have a function that sums numbers. You might want to sum 2 numbers, 3 numbers, or even 10 numbers. Instead of creating different functions for each case, you can use `*args`.

**Example:**

```python
def sum_classic(a,b):
    return a + b

def sum_classic2(a,b,c):
    total = 0
    total += a
    total += b
    total += c
    return total

print(sum_classic2(1, 2, 3))
```

instead of this, we can use `*args`

```python
def sum_all(*args):
    """
    This function sums all the numbers passed as arguments.
    """
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))         # Output: 6
print(sum_all(10, 20, 30, 40))  # Output: 100
```

In this example, `args` is a tuple containing all the positional arguments passed to the function. The name `args` is a convention; you could use any other name, like `*numbers`.

### `**kwargs` (Arbitrary Keyword Arguments)

The `**kwargs` syntax allows a function to accept any number of keyword arguments (arguments with names). These arguments are collected into a dictionary.

**Think of it like this:** Imagine a function that prints user information. Different users might have different attributes (e.g., name, age, city). `**kwargs` lets you handle this flexibility.

**Example:**

```python
def display_user_info(name="John", age=20, city="New York"):
    print(f"name: {name}")
    print(f"age: {age}")
    print(f"city: {city}")
```

This can be done with `**kwargs` like this:

```python
def display_user_info(**kwargs):
    """
    This function displays user information passed as keyword arguments.
    """
    for key, value in kwargs.items():
        print(f"{key}: {value}")

display_user_info(name="Alice", age=30)
# Output:
# name: Alice
# age: 30

display_user_info(name="Bob", city="New York", occupation="Developer")
# Output:
# name: Bob
# city: New York
# occupation: Developer
```

Here, `kwargs` is a dictionary where keys are the argument names and values are the argument values.

### Using `*args` and `**kwargs` Together

You can use both in a single function. The order must be `*args` before `**kwargs`.

**Example:**

```python
def process_data(*args, **kwargs):
    print("Positional arguments (args):", args)
    print("Keyword arguments (kwargs):", kwargs)

process_data(1, 2, 'hello', name='Charlie', status='active')
# Output:
# Positional arguments (args): (1, 2, 'hello')
# Keyword arguments (kwargs): {'name': 'Charlie', 'status': 'active'}
```

> **Note:** In python positional arguments must come before keyword arguments.

## Generators

A generator is a special type of iterator, created using a function with the `yield` keyword. Unlike regular functions that compute a value and return it, generators produce a sequence of values over time. They "yield" one value, pause their state, and wait for the next value to be requested.

**Why use Generators?**

The main advantage is **memory efficiency**. Generators don't store the entire sequence of items in memory. They generate each item on-the-fly, which is incredibly useful when working with very large datasets or infinite sequences.

**Example:** A generator for squaring numbers.

```python
def square_generator(nums):
    for i in nums:
        yield i * i

my_nums = [1, 2, 3, 4, 5]
squares = square_generator(my_nums)

# The values are generated one by one as we iterate
print(next(squares))  # Output: 1
print(next(squares))  # Output: 4

# We can also use it in a for loop
for sq in squares:
    print(sq)
# Output:
# 9
# 16
# 25

print(list(squares)) # Output: [1, 4, 9, 16, 25]

print(next(squares)) # Output: StopIteration
```

The ideal usecase for generators is when you are working with infinite sequences.

**Example:** A generator for fibonacci sequence.

```python
def fibonacci():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

print(fibonacci()) # Output: <generator object fibonacci at ...>

fibonacci_generator = fibonacci()
print(next(fibonacci_generator)) # Output: 0

for i in range(10):
    print(next(fibonacci_generator)) # Output: 1, 1, 2, 3, 5, 8, 13, 21, 34
```

> **Note:** You can also create simple generators using **generator expressions**, which look like list comprehensions but with parentheses.
> 
> ```python
> squares_expr = (x*x for x in my_nums)
> print(squares_expr) # Output: <generator object <genexpr> at ...>
> ```

## Iterators

Most collections in Python are iterable, meaning you can use a `for` loop to iterate over them. But they don't inherently provide an iterator object.

**Example:** An iterator for a list.
```python
my_list = [1, 2, 3, 4, 5]
next(my_list) # Output: TypeError: 'list' object is not an iterator
```

To make a collection iterable, you can use the `iter()` function to get an iterator object.
```python
my_list = [1, 2, 3, 4, 5]
my_iterator = iter(my_list)
print(next(my_iterator)) # Output: 1
print(next(my_iterator)) # Output: 2
```

## Decorators

A decorator is a function that takes another function as an argument, adds some kind of functionality, and then returns another function. This is a powerful way to modify or enhance the behavior of functions without permanently changing their code.

**Think of it like this:** A decorator is like wrapping a gift. The gift (the original function) stays the same, but now it has an extra layer of wrapping (the decorator's functionality) around it.

### Example: A simple decorator to add logging to a function.

```python
# 1. Define the decorator
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func() # 4. Call the original function
        print("Something is happening after the function is called.")
    return wrapper # 5. Return the wrapper

# 2. Apply the decorator using the @ syntax
@my_decorator
def say_hello():
    print("Hello!")

# 3. Call the decorated function
say_hello()
# Output:
# Something is happening before the function is called.
# Hello!
# Something is happening after the function is called.
```

> **Note:** The `@my_decorator` syntax is "syntactic sugar" for `say_hello = my_decorator(say_hello)`. So when you call `say_hello()`, you technically call the `my_decorator(say_hello)()` which is the `wrapper()` function. This in turn prints the logging message and then calls the original `say_hello()` function, finally printing the logging message again.

### Example: A simple decorator to time a function's execution.

```python
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Execution time for {func.__name__}: {end_time - start_time} seconds")
        return result
    return wrapper

@timer_decorator
def long_running_function(seconds=2):
    time.sleep(seconds)
    print(f"Function finished in {seconds} seconds.")

long_running_function()

# Output:
# Function finished in 2 seconds.
# Execution time for long_running_function: 2.0011701583862305 seconds
```

> **Note:** The `@timer_decorator` syntax is "syntactic sugar" for `long_running_function = timer_decorator(long_running_function)`. So when you call `long_running_function(seconds=2)`, you technically call the `timer_decorator(long_running_function)(seconds=2)` which is the `wrapper(seconds=2)` function. This in turn starts the timer, calls the original `long_running_function(seconds=2)` function, which sleeps for 2 seconds and then prints the function finished message, once the original function exits, wrapper function stops the timer and prints the execution time.

### Built-in Decorators

Python comes with several built-in decorators that are commonly used in classes to manage methods and properties.

#### `@staticmethod`

A static method is a method that belongs to a class rather than an instance of the class. It doesn't have access to the instance (`self`) or the class (`cls`). It's essentially a regular function namespaced within the class.

**Use case:** When a utility function is related to a class, but doesn't need to access any class or instance data.

**Example:**
```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

print(MathUtils.add(5, 3))  # Output: 8
```

#### `@classmethod`

A class method is a method that is bound to the class and not the instance. It takes the class itself as the first argument, conventionally named `cls`.

**Use case:** When you need to work with the class, such as for factory methods that create instances of the class in a specific way.

**Example:**
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @classmethod
    def from_birth_year(cls, name, birth_year):
        age = 2025 - birth_year
        return cls(name, age)

person = Person.from_birth_year("Alice", 1995)
print(person.name, person.age) # Output: Alice 30
```

#### `@property`

The `@property` decorator allows you to define methods that can be accessed like attributes. This is useful for creating "getter" methods without needing to call them as functions. You can also define "setter" and "deleter" logic.

**Use case:** When you want to add logic to getting, setting, or deleting an attribute's value.

**Example:**
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """The radius property."""
        print("Getting radius")
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError("Radius cannot be negative")
        print("Setting radius")
        self._radius = value

    @radius.deleter
    def radius(self):
        print("Deleting radius")
        del self._radius

c = Circle(5)
print(c.radius)      # Accessing like an attribute (getter)
c.radius = 7         # Setting like an attribute (setter)
print(c.radius)
del c.radius         # Deleting like an attribute (deleter)

# Output:
# Getting radius
# 5
# Setting radius
# Getting radius
# 7
# Deleting radius
```

## Reading and Writing Files

Interacting with files is a fundamental task. Python provides a straightforward way to read from and write to files.

**The `open()` function:**
- `open('filename.txt', 'r')`: Open for reading (default mode).
- `open('filename.txt', 'w')`: Open for writing (will overwrite the file if it exists).
- `open('filename.txt', 'a')`: Open for appending (will add to the end of the file).
- `open('filename.txt', 'r+')`: Open for both reading and writing.

Python provides a context manager for file operations using the `with` statement. A context manager is a utility that ensures resources are properly opened and closed when the block of code is executed (even if an error occurs).

General syntax:
```python
with open('filename.txt', 'mode') as f:
    # code block that uses the file object f
```

**Example:**

```python
# Writing to a file
with open('hello.txt', 'w') as f:
    f.write('Hello, World!\n')
    f.write('This is a new line.')
```

> **Note:** If the file does not exist, it will be created. If it exists, it will be overwritten.

```python
# Reading from a file
with open('hello.txt', 'r') as f:
    content = f.read()
    print(content)

# Output:
# Hello, World!
# This is a new line.
```

**Example:** Reading a single line from a file.
```python
with open('hello.txt', 'r') as f:
    line1 = f.readline()
    line2 = f.readline()
    print(line1)
    print(line2)
```

**Example:** Reading from a file line by line.
```python
with open('hello.txt', 'r') as f:
    for line in f:
        print(line)
```
or
```python
with open('hello.txt', 'r') as f:
    lines = f.readlines()
    for line in lines:
        print(line)
```

## Introduction to Python's Standard Library

Python comes with a "batteries-included" philosophy, meaning it has a rich and extensive standard library. This library contains a wide range of modules and packages that provide tools for many common programming tasks, from working with text to handling network connections. You don't need to install them separately.

### Pathlib Module

The `pathlib` module provides a object-oriented approach to file system paths. It is a more powerful and flexible way to work with file paths than the `os` module.

```python
from pathlib import Path

path = Path('hello.txt')
print(path.read_text())
```

You can also use the `Path` object to create new paths, join paths, and more in an platform-independent way.
```python
path = Path('.').resolve()

if path.is_dir():
    new_file_path = path/'new.txt'
else:
    new_file_path = path.with_suffix('.txt')

new_file_path.write_text('Hello, World!')
print(new_file_path)
```

### Collections Module

The `collections` module provides specialized, high-performance container datatypes that are alternatives to Python's general-purpose built-in containers like `dict`, `list`, `set`, and `tuple`.

#### `Counter`
A `Counter` is a dictionary subclass for counting hashable objects.

```python
from collections import Counter

my_list = ['a', 'b', 'c', 'a', 'b', 'a']
counts = Counter(my_list)
print(counts)        # Output: Counter({'a': 3, 'b': 2, 'c': 1})
print(counts['a'])   # Output: 3
```

#### `defaultdict`
A `defaultdict` is like a regular dictionary, but if you try to access a key that doesn't exist, it will automatically create it with a default value, instead of raising a `KeyError`.

```python
from collections import defaultdict

# Create a defaultdict where the default value for a missing key is 0
d = defaultdict(int)
d['a'] = 1
print(d['a']) # Output: 1
print(d['b']) # Output: 0 (b was not there, so it was created with int(), which is 0)
```

#### `deque`
A `deque` (deck) is a double-ended queue. It's optimized for fast appends and pops from both ends.

```python
from collections import deque

q = deque([1, 2, 3])
q.append(4)       # Add to the right
q.appendleft(0)   # Add to the left
print(q)          # Output: deque([0, 1, 2, 3, 4])
q.pop()           # Remove from the right
q.popleft()       # Remove from the left
print(q)          # Output: deque([1, 2, 3])
```

### Itertools Module

The `itertools` module provides functions for creating and using iterators for efficient looping.

#### `chain`
Combines multiple iterators into a single one.
```python
from itertools import chain

list1 = [1, 2, 3]
list2 = ['a', 'b']
combined = chain(list1, list2)
for item in combined:
    print(item, end=' ') # Output: 1 2 3 a b
```

#### `product`
Creates the Cartesian product of input iterables. It's equivalent to nested for loops.
```python
from itertools import product

nums = [1, 2]
letters = ['A', 'B']
prod = product(nums, letters)
print(list(prod)) # Output: [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]
```

#### `permutations` and `combinations`
These generate all possible orderings or groupings of items.
```python
from itertools import permutations, combinations

items = ['a', 'b', 'c']
# All possible orderings of length 2
print(list(permutations(items, 2))) # Output: [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]

# All unique combinations of length 2
print(list(combinations(items, 2))) # Output: [('a', 'b'), ('a', 'c'), ('b', 'c')]
```
