# 2.2. Data Manipulation with Pandas

## Vectorized String Operations

```python
monte = pd.Series(['Graham Chapman', 'John Cleese', 'Terry Gilliam', 'Eric Idle', 'Terry Jones', 'Michael Palin'])
monte.str.lower()
```

**Output:**
```
0      graham chapman
1       john cleese
2     terry gilliam
3       eric idle
4      terry jones
5    michael palin
dtype: object
```

```python
monte.str.len()
```

**Output:**
```
0   14
1   11
2   13
3   9
4   11
5   13
dtype: int64
```

```python
monte.str.startswith('T')
```

**Output:**
```
0    False
1    False
2     True
3    False
4     True
5    False
dtype: bool
```

```python
monte.str.split()
```

**Output:**
```
0   [Graham, Chapman]
1   [John, Cleese]
2   [Terry, Gilliam]
3   [Eric, Idle]
4   [Terry, Jones]
5   [Michael, Palin]
dtype: object
```

```python
monte.str[0:3]
```

**Output:**
```
0 Gra
1 Joh
2 Ter
3 Eri
4 Ter
5 Mic
dtype: object
```

```python
monte.str.split().str[-1]
```

**Output:**
```
0 Chapman
1 Cleese
2 Gilliam
3 Idle
4 Jones
5 Palin
dtype: object
```

Python string methods: 
`len` `lower` `translate` `islower` `ljust` \
`upper` `startswith` `isupper` `rjust` `find` \
`endswith` `isnumeric` `center` `rfind` `isalnum` \
`isdecimal` `zfill` `index` `isalpha` `split` \
`strip` `rindex` `isdigit` `rsplit` `rstrip` \
`capitalize` `isspace` `partition` `lstrip` `swapcase` etc.

## Date/Time Manipulation

Pandas has a rich set of tools for working with dates and times, which is essential for time series analysis.

### Time Series Basics

Python’s basic objects for working with dates and times reside in the built-in datetime module. 

```python
from datetime import datetime
datetime(year=2021, month=7, day=4)
```

```python
datetime.datetime(2021, 7, 4, 0, 0)
```

Once you have a datetime object, you can do things like printing the day of the week:

```python
date.strftime('%A')
```

**Output:**
```
Monday
```

> **Note:** `strftime` is a method of datetime objects that formats the date in a string. These are most common format codes: \
> `%Y` - 4-digit year\
> `%y` - 2-digit year\
> `%m` - 2-digit month\
> `%B` - full month name\
> `%b` - abbreviated month name\
> `%A` - full weekday name\
> `%a` - abbreviated weekday name\
> `%d` - 2-digit day\
> `%H` - 2-digit hour (24-hour clock)\
> `%M` - 2-digit minute\
> `%S` - 2-digit second\

There is also timedelta object in python, which represents the difference between two timestamps.

**Example**
```python
datetime.today() - datetime(year=2025, month=9, day=18)
```

**Output**
```
datetime.timedelta(days=91, seconds=53935, microseconds=32500)
```

**Example**
```python
from datetime import timedelta
datetime(year=2025, month=9, day=18) + timedelta(days=1)
```

**Output**
```
datetime.datetime(2025, 9, 19, 0, 0)
```

Similarly, Pandas has `Timestamp` and `Timedelta` objects, which are similar to the `datetime` and `timedelta` objects in Python.

**Example**
```python
pd.Timestamp('2025-12-18') - pd.Timestamp('2025-11-18')
```

**Output**
```
Timedelta('30 days 00:00:00')
```

**Example**
```python
pd.Timestamp('2025-11-18') + pd.Timedelta(3, 'D')
```

**Output**
```
Timestamp('2025-12-21 00:00:00')
```

The `to_datetime()` function can be used to convert strings or other formats to `datetime` objects. Unlike `Timestamp` it can handle multiple dates at once.

```python
date = pd.to_datetime("4th of July, 2021")
date2 = pd.to_datetime(["4th of July, 2021", "5th of July, 2021"])
print(date)
print(date2)
```

**Output:**
```
Timestamp('2021-07-04 00:00:00')
DatetimeIndex(['2021-07-04', '2021-07-05'], dtype='datetime64[ns]', freq=None)
```

```python
date.strftime('%A')
```

**Output:**
```
Monday
```

Similarly, `pd.to_timedelta()` can be used to convert single or multiple strings or other formats to `timedelta` objects.

```python
date + pd.to_timedelta(np.arange(12), 'D')
```

**Output:**
```
DatetimeIndex(['2021-07-04', '2021-07-05', '2021-07-06', '2021-07-07',
               '2021-07-08', '2021-07-09', '2021-07-10', '2021-07-11',
               '2021-07-12', '2021-07-13', '2021-07-14', '2021-07-15'],
              dtype='datetime64[ns]', freq=None)
```

### Indexing by Time
```python
index = pd.DatetimeIndex(['2020-07-04', '2020-08-04', '2021-07-04', '2021-08-04'])
data = pd.Series([0, 1, 2, 3], index=index)
data
```

**Output:**
```
2020-07-04    0
2020-08-04    1
2021-07-04    2
2021-08-04    3
dtype: int64
```

And now that we have this data in a Series, we can make use of any of the Series indexing patterns we discussed in previous chapters, passing values that can be coerced into dates:
```python
data['2020-07-04':'2021-07-04']
```

**Output:**
```
2020-07-04 0
2020-08-04 1
2021-07-04 2
dtype: int64
```

```python
data['2021']
```

**Output:**
```
2021-07-04 2
2021-08-04 3
dtype: int64
```

### Pandas Time Series Data Structures

- For timestamps, Pandas provides the `Timestamp` type. As mentioned before, this is essentially a replacement for Python’s native `datetime`, but it’s based on the more efficient `numpy.datetime64` data type. The associated Index structure is `DatetimeIndex`.
- For time periods, Pandas provides the `Period` type. This encodes a fixedfrequency interval based on `numpy.datetime64`. The associated index structure is `PeriodIndex`.
- For time deltas or durations, Pandas provides the `Timedelta` type. `Timedelta` is a more efficient replacement for Python’s native `datetime timedelta` type, and is based on `numpy.timedelta64`. The associated index structure is `TimedeltaIndex`.

| Pandas Type | Description | Based On | Associated Index | Primary Creation Method |
|---|---|---|---|---|
| `Timestamp` | Replacement for Python's `datetime` | `numpy.datetime64` | `DatetimeIndex` | `pd.Timestamp()` or `pd.to_datetime()` or `pd.date_range()` |
| `Period` | Encodes a fixed-frequency interval | `numpy.datetime64` | `PeriodIndex` | `pd.Period()` or `pd.period_range()` |
| `Timedelta` | Replacement for Python's `datetime.timedelta` | `numpy.timedelta64` | `TimedeltaIndex` | `pd.Timedelta()` or `pd.to_timedelta()` or `pd.timedelta_range()` |

**Example**
```python
dates = pd.to_datetime([datetime(2021, 7, 3), '4th of July, 2021', '2021-Jul-6', '07-07-2021', '20210708'])
dates
```

**Output:**
```
DatetimeIndex(['2021-07-03', '2021-07-04', '2021-07-06', '2021-07-07', '2021-07-08'],
dtype='datetime64[ns]', freq=None)
```

```python
dates.to_period('D')
```

**Output:**
```
PeriodIndex(['2021-07-03', '2021-07-04', '2021-07-06', '2021-07-07', '2021-07-08'],
dtype='period[D]')
```

A `TimedeltaIndex` is created, for example, when a date is subtracted from another:

```python
dates - dates[0]
```

**Output:**
```
TimedeltaIndex(['0 days', '1 days', '3 days', '4 days', '5 days'],
dtype='timedelta64[ns]', freq=None)
```

### Regular Sequences

```python
pd.date_range('2015-07-03', '2015-07-10')
```

**Output:**
```
DatetimeIndex(['2015-07-03', '2015-07-04', '2015-07-05', '2015-07-06', '2015-07-07', '2015-07-08', '2015-07-09', '2015-07-10'],
dtype='datetime64[ns]', freq='D')
```

Alternatively, the date range can be specified not with a start and end point, but with a start point and a number of periods:

```python
pd.date_range('2015-07-03', periods=8)
```

**Output:**
```
DatetimeIndex(['2015-07-03', '2015-07-04', '2015-07-05', '2015-07-06', '2015-07-07', '2015-07-08', '2015-07-09', '2015-07-10'],
dtype='datetime64[ns]', freq='D')
```

The spacing can be modified by altering the freq argument, which defaults to D. For example, here we construct a range of hourly timestamps:

```python
pd.date_range('2015-07-03', periods=8, freq='h')
```

**Output:**
```
DatetimeIndex(['2015-07-03 00:00:00', '2015-07-03 01:00:00',
'2015-07-03 02:00:00', '2015-07-03 03:00:00',
'2015-07-03 04:00:00', '2015-07-03 05:00:00',
'2015-07-03 06:00:00', '2015-07-03 07:00:00'],
dtype='datetime64[ns]', freq='H')
```

To create regular sequences of `Period` or `Timedelta` values, the similar `pd.period_range` and `pd.timedelta_range` functions are useful.

```python
pd.period_range('2015-07', periods=8, freq='M')
```

**Output:**
```
PeriodIndex(['2015-07', '2015-08', '2015-09', '2015-10', '2015-11', '2015-12', '2016-01', '2016-02'],
dtype='period[M]')
```

```python
pd.timedelta_range(0, periods=6, freq='h')
```

**Output:**
```
TimedeltaIndex(['0 days 00:00:00', '0 days 01:00:00', '0 days 02:00:00', '0 days 03:00:00', '0 days 04:00:00', '0 days 05:00:00'],
dtype='timedelta64[ns]', freq='h')
```

**List of Pandas Frequency Aliases**
| Alias | Description | Business Alias |
|---|---|---|
| `A` | Annual | `BYE` - Business year end |
| `Q` | Quarterly | `BQE` - Business quarter end |
| `M` | Monthly | `BME` - Business month end |
| `W` | Weekly | 
| `D` | Calendar daily | `BD` - Business day |
| `h` | Hourly | `bh` - Business hours |
| `min` | Minutely |
| `s` | Secondly |
| `ms` | Milliseonds |
| `us` | Microseconds |
| `ns` | Nanoseconds |


**Start-Indexed Frequency Codes**
| Code | Description | Code | Description |
|---|---|---|---|
| `MS` | Month start | `BMS` | Business month start |
| `QS` | Quarter start | `BQS` | Business quarter start |
| `AS` | Year start | `BAS` | Business year start |

```python
pd.timedelta_range(0, periods=6, freq="2h30min")
```

**Output:**
```
TimedeltaIndex(['0 days 00:00:00', '0 days 02:30:00', '0 days 05:00:00', '0 days 07:30:00', '0 days 10:00:00', '0 days 12:30:00'],
dtype='timedelta64[ns]', freq='150T')
```

### Resampling, Shifting, and Windowing
```python
import yfinance as yf
import datetime

tickers = ['NVDA']

start_date = datetime.datetime(2023, 1, 1)
end_date = datetime.datetime.now()
data = yf.download(tickers, start=start_date, end=end_date)
data = data.droplevel(axis=1, level=1)
print(data)
```

**Output:**
```
Price            Close        High         Low        Open     Volume
Date                                                                 
2023-01-03   14.301480   14.981838   14.082687   14.836974  401277000
2023-01-04   14.735069   14.838971   14.227550   14.553242  431324000
2023-01-05   14.251528   14.550245   14.134638   14.477314  389168000
2023-01-06   14.844967   14.995824   14.020746   14.460330  405044000
2023-01-09   15.613240   16.040836   15.126700   15.269565  504231000
...                ...         ...         ...         ...        ...
2025-11-17  186.600006  189.000000  184.320007  185.970001  173628900
2025-11-18  181.360001  184.800003  179.649994  183.380005  213598900
2025-11-19  186.520004  187.860001  182.830002  184.789993  247246400
2025-11-20  180.639999  196.000000  179.850006  195.949997  343504800
2025-11-21  178.880005  184.559998  172.929993  181.240005  346068500

[726 rows x 5 columns]
```

```python
data = data['Close']
```

One common need when dealing with time series data is resampling at a higher or lower frequency. This can be done using the `resample` method, or the much simpler `asfreq` method. The primary difference between the two is that `resample` is fundamentally a data aggregation, while `asfreq` is fundamentally a data selection. `resample` reports the aggregated value of the given period, while `asfreq` reports the value at the end of the period.

```python
data.resample('BYE').mean()
```

**Output:**
```
Date
2023-12-29     36.542503
2024-12-31    107.780019
2025-12-31    152.702857
Freq: BYE-DEC, Name: Close, dtype: float64
```

> **Note:** You can check these numbers by running the following code:
> ```
> data2 = data.to_frame()
> data2['year'] = data2.index.year.to_list()
> data2.groupby('year').mean()
> ```
> 
> **Output:**
> ```
>            Close
> year            
> 2023   36.542503
> 2024  107.780019
> 2025  152.702857
> ```

```python
data.asfreq('BYE')
```

**Output:**
```
Date
2023-12-29     49.497181
2024-12-31    134.260757
Freq: BYE-DEC, Name: Close, dtype: float64
```

> **Note:** You can check these numbers by running the following code:
> ```
> data['2024-12']
> ```
> 
> **Output:**
> ```
> Date
> 2024-12-02    138.582535
> 2024-12-03    140.211990
> 2024-12-04    145.090332
> 2024-12-05    145.020340
> 2024-12-06    142.401062
> 2024-12-09    138.772034
> 2024-12-10    135.033066
> 2024-12-11    139.271896
> 2024-12-12    137.302429
> 2024-12-13    134.213287
> 2024-12-16    131.963898
> 2024-12-17    130.354340
> 2024-12-18    128.874756
> 2024-12-19    130.644241
> 2024-12-20    134.663162
> 2024-12-23    139.631805
> 2024-12-24    140.181671
> 2024-12-26    139.891739
> 2024-12-27    136.972534
> 2024-12-30    137.452393
> 2024-12-31    134.253281
> Name: Close, dtype: float64
> ```

### Time Shifts

```python
data.shift(-365)
```

**Output:**
```
Date
2023-01-03    130.931259
2023-01-04    135.529541
2023-01-05    130.731339
2023-01-06    126.522888
2023-01-09    118.066032
                 ...    
2025-11-17           NaN
2025-11-18           NaN
2025-11-19           NaN
2025-11-20           NaN
2025-11-21           NaN
Name: Close, Length: 726, dtype: float64
```

```python
data.shift(-365) - data
```

**Output:**
```
Date
2023-01-03    116.629780
2023-01-04    120.794471
2023-01-05    116.479813
2023-01-06    111.677921
2023-01-09    102.452792
                 ...    
2025-11-17           NaN
2025-11-18           NaN
2025-11-19           NaN
2025-11-20           NaN
2025-11-21           NaN
Name: Close, Length: 726, dtype: float64
```

### Rolling Windows

```python
data.rolling(window=365).mean()
```

**Output:**
```
Date
2023-01-03           NaN
2023-01-04           NaN
2023-01-05           NaN
2023-01-06           NaN
2023-01-09           NaN
                 ...    
2025-11-17    141.171006
2025-11-18    141.332583
2025-11-19    141.512246
2025-11-20    141.676101
2025-11-21    141.832663
Name: Close, Length: 726, dtype: float64
```

<!-- TODO: cut, qcut, categorization -->