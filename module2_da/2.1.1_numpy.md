# 2.1 Numerical Computing with NumPy

## Introduction to NumPy

NumPy, which stands for **Numerical Python**, is a fundamental library for numerical computing in Python. It provides a powerful data structure called the **NumPy array** (or `ndarray`, i.e. N-dimensional array), which is a multi-dimensional array object. NumPy arrays are more efficient than Python lists for numerical operations, both in terms of storage and execution speed.

Key features of NumPy include:

*   **Efficient N-dimensional array object:** The `ndarray` is a fast and flexible container for large datasets in Python.
*   **Broadcasting functions:** NumPy allows for operations between arrays of different sizes, a concept known as broadcasting.
*   **Tools for integrating C/C++ and Fortran code:** NumPy provides tools to integrate with code written in other languages.
*   **Useful linear algebra, Fourier transform, and random number capabilities:** NumPy has a rich set of functions for a wide range of mathematical operations.

To get started with NumPy, you first need to install numpy and then import it. 
```pip install numpy```
The standard convention is to import it with the alias `np`:
```python
import numpy as np
```

## NumPy Arrays (ndarrays)

The core of NumPy is the `ndarray` object. These arrays are homogeneous, meaning they can only contain elements of the same data type. This is a key difference from Python lists, which can hold elements of different types.

### Creating NumPy Arrays

You can create NumPy arrays in several ways. The most common method is to create them from Python lists or tuples using the `np.array()` function.

**Example: Creating a 1D array**

```python
# Create a 1D array from a list
my_list = [1, 2, 3, 4, 5]
my_array = np.array(my_list)

print(my_array)
# Output: [1 2 3 4 5]

print(type(my_array))
# Output: <class 'numpy.ndarray'>
```

>**Note**: You can also create a 1D array directly from a list like collection of elements using this syntax: `my_array = np.array([1, 2, 3, 4, 5])`.

**Example: Creating a 2D array (matrix)**

```python
# Create a 2D array from a list of lists
my_2d_list = [[1, 2, 3], [4, 5, 6]]
my_2d_array = np.array(my_2d_list)

print(my_2d_array)
# Output:
# [[1 2 3]
#  [4 5 6]]
```

NumPy also provides several functions to create arrays with initial placeholder content:

*   `np.zeros()`: Creates an array filled with zeros.
*   `np.ones()`: Creates an array filled with ones.
*   `np.empty()`: Creates an array with a specified shape and fills it with random values (not initialized).
*   `np.full()`: Creates an array filled with a specific value.
*   `np.arange()`: Creates an array with a range of numbers.
*   `np.linspace()`: Creates an array with a specified number of elements, spaced equally between two values.
*   `np.random.rand()`: Creates an array of a given shape and populates it with random samples from a uniform distribution over `[0, 1)`.
*   `np.unique()`: Returns the unique elements of an array.

**Examples:**

```python
# Create a 1D array of 5 zeros
zeros_array = np.zeros(5)
print(zeros_array)
# Output: [0. 0. 0. 0. 0.]

# Create a 2x3 array of ones
ones_array = np.ones((2, 3))
print(ones_array)
# Output:
# [[1. 1. 1.]
#  [1. 1. 1.]]

# Create a 2x3 array filled with random values (not initialized)
empty_array = np.empty((2, 3))
print(empty_array)
# Output:
# [[0.12345678 0.87654321 0.45678901]
#  [0.98765432 0.23456789 0.56789012]]

# Create a 2x3 array filled with 5
full_array = np.full((2, 3), 5)
print(full_array)
# Output:
# [[5 5 5]
#  [5 5 5]]

# Create an array with numbers from 0 to 9
range_array = np.arange(10)
print(range_array)
# Output: [0 1 2 3 4 5 6 7 8 9]

# Create an array of 5 numbers evenly spaced between 0 and 1
linspace_array = np.linspace(0, 1, 5)
print(linspace_array)
# Output: [0.   0.25 0.5  0.75 1.  ]

# Create a 2x3 array of random numbers
random_array = np.random.rand(2, 3)
print(random_array)
# Output:
# [[0.12345678 0.87654321 0.45678901]
#  [0.98765432 0.23456789 0.56789012]]
```

```python
# TODO: Explain the theory behind the distributions (uniform, normal, etc.) and show examples of different types of random distributions in the `np.random` module. Include plots. See tools_numpy notebook. To be done in Data Science chapter.
```

### Array Attributes

NumPy arrays have several important attributes that provide information about the array.

*   `ndarray.ndim`: The number of dimensions (or axes) of the array.
*   `ndarray.shape`: A tuple of integers indicating the size of the array in each dimension.
*   `ndarray.size`: The total number of elements in the array.
*   `ndarray.dtype`: An object describing the data type of the array's elements.

**Example:**

```python
# Create a 2D array
my_2d_array = np.array([[1, 2, 3], [4, 5, 6]])

print("Shape of the array:", my_2d_array.shape)
# Output: Shape of the array: (2, 3)

print("Number of dimensions:", my_2d_array.ndim)
# Output: Number of dimensions: 2

print("Size of the array:", my_2d_array.size)
# Output: Size of the array: 6

print("Data type of the array:", my_2d_array.dtype)
# Output: Data type of the array: int32

print("Flattened array:", my_2d_array.flatten())
# Output: Flattened array: [1 2 3 4 5 6]
```

> **Note:** When you iterate over the multi-dimensional array, 
> ```python
> my_2d_array = np.array([[1, 2, 3], [4, 5, 6]])
> 
> for m in my_2d_array:
>     print("Item:")
>     print(m)
> 
> # Output:
> # Item:
> # [1 2 3]
> # Item:
> # [4 5 6]
> 
> for m in my_2d_array.flat:
>     print("Item:")
>     print(m)
> 
> # Output:
> # Item:
> # 1
> # Item:
> # 2
> # Item:
> # 3
> # Item:
> # 4
> # Item:
> # 5
> # Item:
> # 6
> ```

### Reshaping Arrays

You can reshape an array using the `reshape()` method.

**Example:**

```python
my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(my_array.reshape(2, 5))
# Output: 
# [[0 1 2 3 4]
#  [5 6 7 8 9]]
```

### Data Types

Instead of letting NumPy infer the data type from the elements in the array, you can explicitly specify the data type using the `dtype` parameter in the `np.array()` function.

**Example:**

```python
my_array = np.array([1, 2, 3], dtype=np.float32)
print(my_array.dtype, "|", my_array)
# Output: float32 | [1. 2. 3.]

my_array = np.array([1, 2, 3], dtype=np.complex64)
print(my_array.dtype, "|", my_array)
# Output: complex64 | [1.+0.j 2.+0.j 3.+0.j]
```

Available data types include signed integers (`int8`, `int16`, `int32`, `int64`), unsigned integers (`uint8`, `uint16`, `uint32`, `uint64`), floating-point numbers (`float16`, `float32`, `float64`), and complex numbers (`complex64`, `complex128`).


### Array from Functions

You can create arrays from functions using the `np.fromfunction()` function, which takes a function and a shape as arguments and returns a new array. The value of the array at position `(x,y,z,...)` is the result of the function applied to `(x,y,z,...)`.

**Example:**

```python
# Create a 2D array from a function
def my_function(i, j):
    return i + j
my_2d_array = np.fromfunction(my_function, (3, 3))
print(my_2d_array)
# Output:
# [[0. 1. 2.]
#  [1. 2. 3.]
#  [2. 3. 4.]]
```

**Alternative Syntax:**

You can also use a lambda function to create the array.

```python
my_2d_array = np.fromfunction(lambda i, j: i + j, (3, 3))
print(my_2d_array)
# Output:
# [[0. 1. 2.]
#  [1. 2. 3.]
#  [2. 3. 4.]]
```


## Array Indexing and Slicing

Indexing and slicing in NumPy are similar to Python lists, but with more powerful capabilities, especially for multi-dimensional arrays.

### 1D Array Indexing and Slicing

For 1D arrays, indexing and slicing work just like with Python lists.

**Example:**

```python
my_array = np.arange(10)

# Get the first element
print(my_array[0])
# Output: 0

# Get the last element
print(my_array[-1])
# Output: 9

# Get a slice from index 2 to 5 (exclusive)
print(my_array[2:5])
# Output: [2 3 4]

# Get a slice from the beginning to index 5 (exclusive)
print(my_array[:5])
# Output: [0 1 2 3 4]

# Get a slice from index 5 to the end
print(my_array[5:])
# Output: [5 6 7 8 9]

# Get every other element
print(my_array[::2])
# Output: [0 2 4 6 8]

# Get every other element in reverse
print(my_array[::-2])
# Output: [9 7 5 3 1]

# Get elements at specific indices
print(my_array[[0, 2, 4, -1, -2, -3, 2]])
# Output: [0 2 4 9 8 7 2]
```

Once you know the indices you can also modify them
```python
my_array[0] = 10
print(my_array)
# Output: [10 1 2 3 4 5 6 7 8 9]

my_array[2:5] = [100, 200, 300]
print(my_array)
# Output: [10 1 100 200 300 5 6 7 8 9]
```

> **Note:** You can shrink or grow the Python list by assigning a shorter or longer list to the slice.
> ```python
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = [100]
> print(my_list)
> # Output: [0, 1, 100, 5, 6, 7, 8, 9]
> 
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = [100, 200, 300, 400, 500]
> print(my_list)
> # Output: [0, 1, 100, 200, 300, 400, 500, 5, 6, 7, 8, 9]
> ```
> 
> Assigning a single value to a Python list will not work and will raise a TypeError.
> 
> ```python
> my_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
> my_list[2:5] = 100
> print(my_list)
> # Output: TypeError: can only assign an iterable
> ```
> 
> In contrast, assigning a single value to a NumPy array will work.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = 100
> print(my_array)
> # Output: [0, 1, 100, 100, 100, 5, 6, 7, 8, 9]
> ```
> 
> But you cannot grow the array by assigning a longer list to the slice, you will get a ValueError.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = [100]
> print(my_array)
> # Output: ValueError: could not broadcast input array from shape (5,) into shape (3,)
> ```
> 
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> my_array[2:5] = [100, 200, 300, 400, 500]
> print(my_array)
> # Output: [0, 1, 100, 200, 300, 400, 500, 5, 6, 7, 8, 9]
> ```
> Or you cannot delete a slice of the array, you will get a ValueError.
> ```python
> my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
> del my_array[2:5]
> print(my_array)
> # Output: ValueError: cannot delete array elements
> ```

Similar to Python lists, modifying an element of the slice will modify the original array.

```python
my_array = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
my_slice = my_array[2:5]
my_slice[1] = 1000
print(my_array)
# Output: [0, 1, 2, 1000, 4, 5, 6, 7, 8, 9]
```

If you want a copy of the data, you can use the `copy()` method.
```python
my_slice = my_array[2:5].copy()
my_slice[1] = 1000
print(my_array)
# Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(my_slice)
# Output: [2, 1000, 4]
```

### 2D Array Indexing and Slicing

For 2D arrays, you can use a comma-separated tuple of indices to access elements.

**Example:**

```python
my_2d_array = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Get the element at row 1, column 2
print(my_2d_array[1, 2])
# Output: 6

# You can also use the syntax my_2d_array[1][2]
print(my_2d_array[1][2])
# Output: 6
```

Slicing 2D arrays allows you to select sub-arrays.

**Example:**

```python
# Get the first two rows
print(my_2d_array[:2])
# Output:
# [[1 2 3]
#  [4 5 6]]

# Get the first two rows and all columns
print(my_2d_array[:2, :])
# Output:
# [[1 2 3]
#  [4 5 6]]

# Get all rows and the first two columns
print(my_2d_array[:, :2])
# Output:
# [[1 2]
#  [4 5]
#  [7 8]]

# Get a sub-array from the first two rows and columns 1 to the end
print(my_2d_array[:2, 1:])
# Output:
# [[2 3]
#  [5 6]]

# Get a sub-array from row 1 to row 3 (exclusive) and columns 1 to the end
print(my_2d_array[1:3, 1:])
# Output:
# [[5 6]
#  [8 9]]

# Get a sub-array from rows 0 and 2 (inclusive) and columns 2 to the end
print(my_2d_array[[0, 2], 2:])
# Output:
# [[3]
#  [9]]

# Get a sub-array from rows 0 and 2 (inclusive) and columns 2 to the end
print(my_2d_array[[0, 2, 1, 1], 2:])
# Output:
# [[3]
#  [9]
#  [6]
#  [6]]
```

### Ellipsis

**Example:**

```python
c = np.array([[[ 0,  1,  2,  3,  4,  5],
        [ 6,  7,  8,  9, 10, 11]],

       [[12, 13, 14, 15, 16, 17],
        [18, 19, 20, 21, 22, 23]],

       [[24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35]],

       [[36, 37, 38, 39, 40, 41],
        [42, 43, 44, 45, 46, 47]]])

print(c[2, 1, 4]) # matrix 2, row 1, col 4
# Output: 34

c[2, :, 3]  # matrix 2, all rows, col 3
# Output: [27 33]

c[2, 1]  # Return matrix 2, row 1, all columns.  This is equivalent to c[2, 1, :]
# Output: [30 31 32 33 34 35]
```

Ellipsis is a special constant that can be used to represent any number of dimensions. When you write ellipsis in the index, all non-specified dimensions are included.
```python
c[2, ...]  #  matrix 2, all rows, all columns.  This is equivalent to c[2, :, :]
# Output: 
# array([[24, 25, 26, 27, 28, 29],
#        [30, 31, 32, 33, 34, 35]])

c[2, 1, ...]  # matrix 2, row 1, all columns.  This is equivalent to c[2, 1, :]
# Output: array([30, 31, 32, 33, 34, 35])

c[2, ..., 3]  # matrix 2, all rows, column 3.  This is equivalent to c[2, :, 3]
# Output: array([27, 33])

c[..., 3]  # all matrices, all rows, column 3.  This is equivalent to c[:, :, 3]
# Output: 
# array([[ 3,  9],
#        [15, 21],
#        [27, 33],
#        [39, 45]])
```

### Boolean Indexing

Boolean indexing allows you to select elements from an array based on a condition.

**Example:**

```python
my_array = np.array([1, 2, 3, 4, 5, 6])

# Create a boolean array
bool_array = my_array > 3
print(bool_array)
# Output: [False False False  True  True  True]

# Use the boolean array to select elements
print(my_array[bool_array])
# Output: [4 5 6]

# You can also do this in one line
print(my_array[my_array > 3])
# Output: [4 5 6]
```

The same also works with multi-dimensional arrays.
```python
b = np.arange(48).reshape(4, 12)

rows_on = np.array([True, False, True, False])
b[rows_on, :]  # Rows 0 and 2, all columns. Equivalent to b[(0, 2), :]
# Output:
# array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],
#        [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]])
```

For multiple axes, you can use a tuple of indices, with `np.ix_` to generate the boolean indices for each axis.
```python
rows_on = np.array([True, False, True, False])
cols_on = np.array([False, True, False] * 4)
b[np.ix_(rows_on, cols_on)]
# Output:
# array([[ 1,  4,  7, 10],
#        [25, 28, 31, 34]])
```
