# 2.1 Numerical Computing with NumPy

## Array Operations

NumPy allows you to perform element-wise operations on arrays, which are very efficient.

### Vectorized Operations

Vectorized operations are operations that are applied to entire arrays at once, without the need for explicit loops.

**Example: Basic Arithmetic**

```python
array1 = np.array([1, 2, 3])
array2 = np.array([4, 5, 6])

# Element-wise addition
print(array1 + array2)
# Output: [5 7 9]

# Element-wise subtraction
print(array1 - array2)
# Output: [-3 -3 -3]

# Element-wise multiplication
print(array1 * array2)
# Output: [ 4 10 18]

# Element-wise division
print(array1 / array2)
# Output: [0.25 0.4  0.5 ]
```

You can also perform operations between an array and a scalar.

**Example: Operations with a Scalar**

```python
my_array = np.array([1, 2, 3])

# Add 10 to each element
print(my_array + 10)
# Output: [11 12 13]

# Multiply each element by 2
print(my_array * 2)
# Output: [2 4 6]

# Square each element
print(my_array ** 2)
# Output: [1 4 9]
```

### Broadcasting

Broadcasting is a powerful mechanism that allows NumPy to work with arrays of different shapes when performing arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes.

#### The Rules of Broadcasting

When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e., rightmost) dimensions and works its way left. Two dimensions are compatible when:

1.  they are equal, or
2.  one of them is 1.

If these conditions are not met, a `ValueError: operands could not be broadcast together` is thrown.

Let's break down the process:

1.  **Rule 1: Pad Dimensions**
    If the two arrays differ in their number of dimensions, the shape of the one with fewer dimensions is padded with ones on its leading (left) side.

2.  **Rule 2: Stretch Dimensions**
    If the shape of the two arrays does not match in any dimension, the array with a shape equal to 1 in that dimension is stretched to match the other shape.

3.  **Rule 3: Raise Error**
    If in any dimension the sizes disagree and neither is equal to 1, an error is raised.

**Example 1: Broadcasting a 1D array across a 2D array**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
]) # Shape: (2, 3)

my_1d_array = np.array([10, 20, 30]) # Shape: (3,)
```

Let's apply the rules:
- **Shapes:** `my_2d_array` is `(2, 3)` and `my_1d_array` is `(3,)`.
- **Rule 1:** Pad the shape of `my_1d_array` to match the number of dimensions. It becomes `(1, 3)`.
- **Rule 2:** Compare dimensions right to left:
    - `3` vs `3`: They are equal.
    - `2` vs `1`: The `1` is stretched to match the `2`.
- The effective shape of `my_1d_array` becomes `(2, 3)`, and the addition can proceed.

```python
# Add the 1D array to each row of the 2D array
result = my_2d_array + my_1d_array

print(result)
# Output:
# [[11 22 33]
#  [14 25 36]]
```

**Example 2: Broadcasting a column vector**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
]) # Shape: (2, 3)

my_col_vector = np.array([
    [10], 
    [20]
]) # Shape: (2, 1)
```
Let's apply the rules:
- **Shapes:** `my_2d_array` is `(2, 3)` and `my_col_vector` is `(2, 1)`.
- **Rule 1:** Both have 2 dimensions, so no padding is needed.
- **Rule 2:** Compare dimensions right to left:
    - `3` vs `1`: The `1` is stretched to match the `3`.
    - `2` vs `2`: They are equal.
- The effective shape of `my_col_vector` becomes `(2, 3)`.

```python
# Add the column vector to each column of the 2D array
result = my_2d_array + my_col_vector

print(result)
# Output:
# [[11 12 13]
#  [24 25 26]]
```

### Stacking Arrays

Stacking arrays is the process of combining multiple arrays along a new axis.

**Example:**

```python
q1 = np.full((3,4), 1.0)
q2 = np.full((4,4), 2.0)
q3 = np.full((3,4), 3.0)

q4 = np.vstack((q1, q2, q3))
q4
# Output:
# array([[1., 1., 1., 1.],
#        [1., 1., 1., 1.],
#        [1., 1., 1., 1.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [2., 2., 2., 2.],
#        [3., 3., 3., 3.],
#        [3., 3., 3., 3.],
#        [3., 3., 3., 3.]])

q5 = np.hstack((q1, q3))
q5
# Output:
# array([[1., 1., 1., 1., 3., 3., 3., 3.],
#        [1., 1., 1., 1., 3., 3., 3., 3.],
#        [1., 1., 1., 1., 3., 3., 3., 3.]])
```

The `stack` function stacks arrays along a new axis. All arrays have to have the same shape.
```python
q8 = np.stack((q1, q3))
q8
# Output:
# array([[[1., 1., 1., 1.],
#         [1., 1., 1., 1.],
#         [1., 1., 1., 1.]],
# 
#        [[3., 3., 3., 3.],
#         [3., 3., 3., 3.],
#         [3., 3., 3., 3.]]])
```

There is also a convenience function called `concatenate` that can be used to stack arrays along a given axis.

#### Understanding the `axis` Parameter

The `axis` parameter tells NumPy which dimension to operate on. It can be confusing, but here’s an easy way to think about it for a 2D array (a matrix):

-   **`axis=0`**: This refers to the **first dimension**, which is the **rows**. When you operate along `axis=0`, you are performing an operation *down the rows*. For concatenation, this means you are stacking the arrays **vertically**, one on top of the other.
-   **`axis=1`**: This refers to the **second dimension**, which is the **columns**. When you operate along `axis=1`, you are performing an operation *across the columns*. For concatenation, this means you are stacking the arrays **horizontally**, side-by-side.

Think of the `axis` as the dimension that will be "glued" together. When you concatenate along an axis, the arrays must have the same shape in all other dimensions.

**Example with `concatenate`:**

Let's see how this works with two 2x2 arrays:

```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

# Concatenate along axis=0 (stacking vertically)
# The number of columns (axis=1) must match.
vertical_stack = np.concatenate((a, b), axis=0)
print("Vertical Stack (axis=0):\n", vertical_stack)
# Output:
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]

# Concatenate along axis=1 (stacking horizontally)
# The number of rows (axis=0) must match.
horizontal_stack = np.concatenate((a, b), axis=1)
print("\nHorizontal Stack (axis=1):\n", horizontal_stack)
# Output:
# [[1 2 5 6]
#  [3 4 7 8]]
```

Now, let's look at the original example from the `vstack` section:

```python
q7 = np.concatenate((q1, q2, q3), axis=0)
q7 # Equivalent to q4 (vertical stack)
```

### Splitting Arrays
Splitting is the opposite of stacking. It is the process of dividing an array into multiple sub-arrays.
```python
r = np.arange(24).reshape(6,4)
r
# Output:
# array([[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11],
#        [12, 13, 14, 15],
#        [16, 17, 18, 19],
#        [20, 21, 22, 23]])

r1, r2, r3 = np.vsplit(r, 3)
r4, r5 = np.hsplit(r, 2)
r6, r7 = np.split(r, 2, axis=1) # Equivalent to r4, r5
```

### Transposing Arrays
Transposing an array is the process of flipping it over its diagonal.
```python
r.T
# Output:
# array([[ 0,  4,  8, 12, 16, 20],
#        [ 1,  5,  9, 13, 17, 21],
#        [ 2,  6, 10, 14, 18, 22],
#        [ 3,  7, 11, 15, 19, 23]])

r.transpose((1, 0)) # Equivalent to r.T
# Output:
# array([[ 0,  4,  8, 12, 16, 20],
#        [ 1,  5,  9, 13, 17, 21],
#        [ 2,  6, 10, 14, 18, 22],
#        [ 3,  7, 11, 15, 19, 23]])
```

The `T` attribute has no effect on 1D arrays.
```python
r1 = np.array([1, 2, 3, 4])
r1.T
# Output: array([1, 2, 3, 4])
```

You need to use the `reshape` function to transpose a 1D array.
```python
r1 = np.array([1, 2, 3, 4])
r2 = r1.reshape(1, 4)
# Output:
# array([[1, 2, 3, 4]])
r2.reshape(4, 1)
# Output:
# array([[1],
#        [2],
#        [3],
#        [4]])
```

## Mathematical and Statistical Functions

NumPy provides a wide range of mathematical and statistical functions that can be applied to arrays.

**Example: Basic Functions**

```python
my_array = np.array([1, 4, 9, 16])

# Get the square root of each element
print(np.sqrt(my_array))
# Output: [1. 2. 3. 4.]

# Get the exponential of each element
print(np.exp(my_array))
# Output: [2.71828183e+00 5.45981500e+01 8.10308393e+03 8.88611052e+06]
```

**Example: Statistical Functions**

```python
my_2d_array = np.array([
    [1, 2, 3], 
    [4, 5, 6]
])

# Get the sum of all elements
print(np.sum(my_2d_array))
# Output: 21

# Get the sum of elements along each column
print(np.sum(my_2d_array, axis=0))
# Output: [5 7 9]

# Get the sum of elements along each row
print(np.sum(my_2d_array, axis=1))
# Output: [ 6 15]

# Get the mean of all elements
print(np.mean(my_2d_array))
# Output: 3.5

# Get the standard deviation
print(np.std(my_2d_array))
# Output: 1.707825127659933
```

## Linear Algebra with NumPy

NumPy provides a `linalg` module that contains a rich set of functions for linear algebra operations.

**Example: Matrix Multiplication**

To perform matrix multiplication, you can use the `@` operator or the `np.dot()` function.

```python
matrix1 = np.array([[1, 2], [3, 4]])
matrix2 = np.array([[5, 6], [7, 8]])

# Using the @ operator
result1 = matrix1 @ matrix2
print(result1)
# Output:
# [[19 22]
#  [43 50]]

# Using np.dot()
result2 = np.dot(matrix1, matrix2)
print(result2)
# Output:
# [[19 22]
#  [43 50]]
```

> **Note**: `matrix1 * matrix2` is not the same as `matrix1 @ matrix2`. It is element-wise multiplication also called "Hadamard product".
> ```python
> matrix1 = np.array([[1, 2], [3, 4]])
> matrix2 = np.array([[5, 6], [7, 8]])
> 
> # Using the * operator
> result3 = matrix1 * matrix2
> print(result3)
> # Output: [[ 5 12] [21 32]]
> ```

**Example: Inverse of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the inverse of the matrix
inverse_matrix = np.linalg.inv(my_matrix)

print(inverse_matrix)
# Output:
# [[-2.   1. ]
#  [ 1.5 -0.5]]

pseudo_inverse_matrix = np.linalg.pinv(my_matrix)

print(pseudo_inverse_matrix)
# Output:
# [[-2.   1. ]
#  [ 1.5 -0.5]]

np.allclose(my_matrix @ pseudo_inverse_matrix, np.eye(2))
# Output: True
```

**Note**: `np.linalg.pinv` is the pseudo-inverse of a matrix. It is a generalization of the inverse for non-square matrices. `np.allclose` is a function that checks if two matrices are close to each other within a specified tolerance. `np.eye(2)` creates a 2x2 identity matrix (matrix with ones on the diagonal and zeros elsewhere).

**Example: Determinant of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the determinant of the matrix
determinant = np.linalg.det(my_matrix)

print(determinant)
# Output: -2.0000000000000004
```

**Example: Diagonal of a Matrix**

```python
my_matrix = np.array([[1, 2], [3, 4]])

# Calculate the diagonal of the matrix
diagonal = np.diag(my_matrix)

print(diagonal)
# Output: [1 4]
```

### Solving a system of linear scalar equations
The `solve` function solves a system of linear scalar equations, such as:

* $2x + 6y = 6$
* $5x + 3y = -9$

```python
coeffs  = np.array([[2, 6], [5, 3]])
depvars = np.array([6, -9])
solution = linalg.solve(coeffs, depvars)
solution
# Output: array([-3.,  2.])

coeffs.dot(solution), depvars
# Output: (array([6., -9.]), array([6., -9.]))