# 2.2. Data Manipulation with Pandas

## Introduction to Pandas

Pandas is a powerful and popular open-source Python library for data manipulation and analysis. It provides high-performance, easy-to-use data structures, and data analysis tools. The name "Pandas" is derived from "Panel Data," an econometrics term for multidimensional, structured data sets.

Pandas is a cornerstone of data science in Python, offering two primary data structures that are fundamental to data manipulation: the `Series` and the `DataFrame`.

To install pandas you should activate the environment and run
```
pip install pandas
```

## Pandas Data Structures: Series

A **Series** is a one-dimensional labeled array capable of holding any data type (integers, strings, floating-point numbers, Python objects, etc.). It is similar to a column in a spreadsheet or a single column from a database table.

**Example: Creating a Series**

To create a Series, you can pass a list of values to the `pd.Series()` constructor.

```python
import pandas as pd

# Creating a Series from a list
data = [2,-1,3,5]
s = pd.Series(data)
print(s)
```

**Output:**

```
0    2
1   -1
2    3
3    5
dtype: int64
```

`Series` objects behave much like one-dimensional NumPy `ndarray`s, and you can often pass them as parameters to NumPy functions:
```python
import numpy as np
np.exp(s)
```

**Output:**

```
0      7.389056
1      0.367879
2     20.085537
3    148.413159
dtype: float64
```

Arithmetic operations on `Series` are also possible, and they apply *elementwise*, just like for `ndarray`s:
```python
s + [1000,2000,3000,4000]
```

**Output:**

```
0    1002
1    1999
2    3003
3    4005
dtype: int64
```

Similar to NumPy, if you add a single number to a `Series`, that number is added to all items in the `Series`. This is called *broadcasting*:

```python
s + 1000
```

**Output:**

```
0    1002
1     999
2    1003
3    1005
dtype: int64
```

The same is true for all binary operations such as `*` or `/`, and even conditional operations:

```python
s < 0
```

**Output:**

```
0    False
1     True
2    False
3    False
dtype: bool
```

### Index
By default, index is simply the rank of the item in the `Series` (starting from `0`) but you can also set the index labels manually:

```python
s2 = pd.Series(
    [68, 83, 112, 68], 
    index=["alice", "bob", "charles", "darwin"]
)
s2
```

**Output:**

```
alice       68
bob         83
charles    112
darwin      68
dtype: int64
```

> **Note:** You can also access the index of the `Series` using the `index` attribute.
> s2.index
> 
> **Output:**
> ```
> Index(['alice', 'bob', 'charles', 'darwin'], dtype='object')
> ```

> **Note:** If you initialize a `Series` with a scalar value and a list of indices, the scalar value is repeated for each index.
>
> ```python
> pd.Series(42, ["life", "universe", "everything"])
> ```
>
> **Output:**
>
> ```
> life          42
> universe      42
> everything    42
> dtype: int64
> ```

You can then use the `Series` just like a `dict`:

```python
s2["bob"]
```

**Output:**

```
83
```

You can also use the `Series` as a dictionary to set values:

```python
s2["bob"] = 100
print(s2)
```

To make it clear when you are accessing by label or by integer location, it is recommended to always use the `loc` attribute when accessing by label, and the `iloc` attribute when accessing by integer location:

```python
s2.loc["bob"]
```

**Output:**

```
83
```

```python
s2.iloc[1]
```

**Output:**

```
83
```
Slicing a Series is similar to slicing a list:

```python
s2.iloc[1:3]
```

**Output:**

```
bob         83
charles    112
dtype: int64
```

### Alternative Constructor

You can also create a `Series` from a dictionary:

```python
weights = {"alice": 68, "bob": 83, "colin": 86, "darwin": 68}
s3 = pd.Series(weights)
s3
```

**Output:**

```
alice     68
bob       83
colin     86
darwin    68
dtype: int64
```

### Automatic Alignment

When you perform arithmetic operations on `Series`, the operations are performed element-wise, and the indices of the `Series` are automatically aligned.

```python
s3 + s2
```

**Output:**

```
alice      136.0
bob        166.0
charles      NaN
colin        NaN
darwin     136.0
dtype: float64
```

> **Note:** NaN stands for "Not a Number" and is used to represent missing values.

### Name of the Series

You can also set the name of the `Series` using the `name` parameter:

```python
s6 = pd.Series([83, 68], index=["bob", "alice"], name="weights")
s6
```

**Output:**

```
bob      83
alice    68
Name: weights, dtype: int64
```

### Conditional Replace

```python
s = pd.Series([1, 2, 3, 4, 5])
s.loc[s > 3] = 10
s
```

**Output:**

```
0     1
1     2
2     3
3    10
4    10
dtype: int64
```

The `.where()` method replaces values where the condition is False. 

```python
s = pd.Series([1, 2, 3, 4, 5])
s.where(s > 3, 0)
```

**Output:**

```
0    0
1    0
2    0
3    4
4    5
dtype: int64
```

The `.mask()` method replaces values where the condition is True.

```python
s.mask(s > 3, 0)
```

**Output:**

```
0    1
1    2
2    3
3    0
4    0
dtype: int64
```

`numpy` `where()` allows you to specify a different value for both the `True` and `False` cases, making it a flexible option for "if-else" style replacements.

```python
s = pd.Series([1, 2, 3, 4, 5])
s.loc[:] = np.where(s > 3, 10, 0)
s
```

**Output:**

```
0    0
1    0
2    0
3   10
4   10
dtype: int64
```

### Counting values
```python
s = pd.Series([1, 1, 2, 2, 2, 3, 3, 4])
s.value_counts()
```

**Output:**

```
2    3
1    2
3    2
4    1
Name: count, dtype: int64
```

`value_counts()` can also be normalized to a percentage by setting the `normalize` parameter to `True`.

```python
s.value_counts(normalize=True)
```

**Output:**

```
2    0.375
1    0.250
3    0.250
4    0.125
```

```python
buckets = [0, 3, 6, 9]
s.value_counts(bins = buckets)
```

**Output:**

```
(-0.001, 3.0]    7
(3.0, 6.0]       1
(6.0, 9.0]       0
Name: count, dtype: int64
```

### Applying a Function

```python
s = pd.Series([1, 1, 2, 2, 2, 3, 3, 4])
s.apply(lambda x: x * 2)
```

**Output:**

```
0     2
1     2
2     4
3     4
4     4
5     6
6     6
7     8
dtype: int64
```

```python
def even_or_odd(n):
    if n % 2 == 0:
        return "Even"
    else:
        return "Odd"
s.apply(even_or_odd)
```

**Output:**

```
0      Even
1      Even
2      Odd
3      Odd
4      Odd
5      Even
6      Even
7      Odd
dtype: object
```

### Series Utils 

| Utility | Description |
|------|-------------|
| `s.values` | Returns the values of the `Series` as a NumPy array. |
| `list(s)` | Returns the values of the `Series` as a list. |
| `s.index` | Returns the index of the `Series`. |
| `s.shape` | Returns the shape of the `Series` (tuple of the form (length,)). |
| `len(s)` | Returns the length of the `Series` (int). |
| `'bob' in s` | Checks if 'bob' is in the `Series` index. |
| `s.isnull()` | Returns a `Series` of booleans indicating if a value is missing. |
| `s.notnull()` | Returns a `Series` of booleans indicating if a value is not missing. |
| `s.sort_values()` | Returns a new `Series` with the values sorted in ascending order (`ascending=True, na_position="last"`). |
| `s.sort_index()` | Returns a new `Series` with the index sorted in ascending order (`ascending=True, na_position="last"`). |
| `s.head(n)` | Returns the first n elements of the `Series`. |
| `s.tail(n)` | Returns the last n elements of the `Series`. |
| `s.unique()` | Returns a `np.ndarray` with the unique values of the `Series`. |
| `s.nunique()` | Returns the number of unique values in the `Series`. |
| `s.dropna()` | Returns a new `Series` with missing values dropped. |
| `s.fillna(value)` | Returns a new `Series` with missing values filled with the specified value. |
| `s.nlargest(n)` | Returns the n largest values of the `Series`. |
| `s.nsmallest(n)` | Returns the n smallest values of the `Series`. |