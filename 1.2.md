# 1.2: Data Structures and Control Flow

## Introduction to Data Structures

Data structures are a way of organizing and storing data in a computer so that it can be accessed and used efficiently. Python has several built-in data structures, and in this section, we will focus on lists and tuples.

## Lists

A list is an ordered and **mutable** (changeable) collection of items. Lists can contain items of different data types.

### Creating Lists

You create a list by placing items inside square brackets `[]`, separated by commas.

```python
# A list of integers
numbers = [1, 2, 3, 4, 5]

# A list of strings
fruits = ["apple", "banana", "cherry"]

# A list with mixed data types
mixed_list = ["hello", 3.14, True, 42]
```

### List Membership

You can check if an item is in a list using the `in` operator.

```python
print("apple" in fruits) # Output: True
print("pineapple" in fruits) # Output: False
```

You can also check if an item is not in a list using the `not in` operator.

```python
print("apple" not in fruits) # Output: False
print("pineapple" not in fruits) # Output: True
```

### Indexing and Slicing

You can access elements in lists and other sequence types (like strings and tuples) using indexing and slicing.

*   **Indexing:** Access individual items using their index. Python is zero-indexed, meaning the first item is at index 0.

    ```python
    fruits = ["apple", "banana", "cherry"]
    print(fruits[0])  # Output: apple
    print(fruits[2])  # Output: cherry
    ```

*   **Negative Indexing:** You can also use negative indices to access items from the end of the list. `-1` refers to the last item, `-2` to the second-to-last, and so on.

    ```python
    print(fruits[-1]) # Output: cherry
    print(fruits[-2]) # Output: banana
    ```

*   **Slicing:** Access a range of items by specifying a `start` and `end` index (`start:end`). The slice will include the element at the `start` index but **exclude** the element at the `end` index.

    ```python
    numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    print(numbers[1:5])  # Output: [1, 2, 3, 4]
    print(numbers[:4])   # Output: [0, 1, 2, 3] (from the beginning up to index 4)
    print(numbers[5:])   # Output: [5, 6, 7, 8, 9] (from index 5 to the end)
    ```

*   **Slicing with a Step:** You can also provide a "step" value to your slice (`start:end:step`). This allows you to skip elements.

    ```python
    print(numbers[0:10:2]) # Output: [0, 2, 4, 6, 8] (every second element)
    ```

*   **Reversing a List with Slicing:** A common trick is to use a step of `-1` to reverse a list.

    ```python
    print(numbers[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
    ```


### Modifying Lists

Since lists are mutable, you can change their content.

*   **Change an item:**
    ```python
    fruits[1] = "blueberry"
    print(fruits)  # Output: ['apple', 'blueberry', 'cherry']
    ```
*   **Change multiple items:**
    ```python
    fruits[1:3] = ["blueberry", "grape"]
    print(fruits)  # Output: ['apple', 'blueberry', 'grape']
    ```
*   **Delete an item:**
    ```python
    del fruits[1]
    print(fruits)  # Output: ['apple', 'grape', 'cherry']
    ```
*   **Delete multiple items:**
    ```python
    del fruits[1:3]
    print(fruits)  # Output: ['apple', 'cherry']
    ```
*   **List concatenation:**
    ```python
    fruits1 = ["apple", "banana", "cherry"]
    fruits2 = ["orange", "mango", "pineapple"]
    fruits = fruits1 + fruits2
    print(fruits)  # Output: ['apple', 'banana', 'cherry', 'orange', 'mango', 'pineapple']
    ```
*   **List repetition:**
    ```python
    fruits = ["apple"] * 3
    print(fruits)  # Output: ['apple', 'apple', 'apple']
    ```

### List Methods

| Method | Description |
| :----- | :---------- |
| `.append(item)` | Adds an item to the end of the list. |
| `.insert(index, item)` | Adds an item at a specified index. |
| `.extend(items)` | Adds multiple items to the end of the list. |
| `.remove(item)` | Removes the first occurrence of a specified value. |
| `.pop(index)` | Removes an item at a specified index (or the last item if the index is not provided). |
| `.clear()` | Removes all items from the list. |
| `.sort()` | Sorts the list in ascending order. |
| `.reverse()` | Reverses the list. |
| `.copy()` | Returns a copy of the list. |
| `.count(item)` | Returns the number of occurrences of a specified value. |
| `.index(item)` | Returns the index of the first occurrence of a specified value. |

#### Examples:
*   `append()`: Adds an item to the end of the list.
    ```python
    fruits.append("orange")
    print(fruits) # Output: [...existing items..., 'orange']
    ```
*   `insert()`: Adds an item at a specified index.
    ```python
    fruits.insert(1, "grape")
    print(fruits) # Output: [...existing items..., 'grape', ...existing items...]
    ```
*   `extend()`: Adds multiple items to the end of the list.
    ```python
    fruits.extend(["mango", "pineapple"])
    print(fruits) # Output: [...existing items..., 'mango', 'pineapple']
    ```
*   `remove()`: Removes the first occurrence of a specified value.
    ```python
    fruits.remove("cherry")
    ```

> **Note**: `.remove()` vs `del`.
> * `.remove()` removes the first occurrence of a specified value.
> * `del` removes the item at a specified index.


*   `pop()`: Removes an item at a specified index (or the last item if the index is not provided).
    ```python
    fruits.pop(1)
    ```

> **Note**: 
> `len()` is a function that returns the length of the list.
> ```python
> fruits = ["apple", "banana", "cherry"]
> len(fruits) # Output: 3
> ```

### Nested Lists

A nested list is a list that contains other lists as its elements.

```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(nested_list[0]) # Output: [1, 2, 3]
print(nested_list[0][1]) # Output: 2
```

## Tuples

A tuple is an ordered and **immutable** (unchangeable) collection of items. Once a tuple is created, you cannot change its values.

### Creating Tuples

You create a tuple by placing items inside parentheses `()`, separated by commas.

```python
# A tuple of numbers
point = (10, 20)

# A tuple of strings
colors = ("red", "green", "blue")
```

### When to use Tuples?

Use tuples when you have data that should not change, such as coordinates, dates, or configuration settings. Their immutability makes your code safer from accidental changes.

## Logical Operators

| Operator | Description |
| :------- | :---------- |
| `and` | Returns `True` if both operands are `True`. |
| `or` | Returns `True` if at least one operand is `True`. |
| `not` | Returns the opposite of the operand. |

```python
print(True and True) # Output: True
print(True or False) # Output: True
print(not True) # Output: False
print(not False) # Output: True
```

> **Note**: `and` has higher precedence than `or`.
> ```python
> print(True and False or True) # Output: True
> print(True and (False or True)) # Output: True
> print(True and True and False) # Output: False
> ```

### Chained Comparison Operators

You can chain multiple comparison operators to check if a value is within a range.

```python
1 < 5 < 10 # Output: True
1 < 5 and 5 < 10 # Output: True

1 < 5 < 3 # Output: False
1 < 5 and 5 < 3 # Output: False

1 < 3 > 2 # Output: True
1 < 3 and 3 > 2 # Output: True
```

## Conditional Statements

Conditional statements allow you to execute certain blocks of code based on whether a condition is true or false.

### `if`, `elif`, and `else`

*   `if`: The block of code under `if` is executed if the condition is `True`.
*   `elif` (else if): If the first `if` condition is `False`, Python checks the `elif` condition.
*   `else`: If all preceding conditions are `False`, the `else` block is executed.

> **Note on indentation**:
> The code block under `if`, `elif`, and `else` is indented. This is how Python knows which code block to execute.
> ```python
> if condition:
>     # code block
> elif condition:
>     # code block
> else:
>     # code block
> ```

```python
age = 18

if age < 13:
    print("You are a child.")
elif age < 20:
    print("You are a teenager.")
else:
    print("You are an adult.")
# Output: You are a teenager.
```

### Nested Conditional Statements

You can nest conditional statements inside other conditional statements.

```python
if condition1:
    if condition2:
        # code block
    else:
        # code block
elif condition3:
    # code block
else:
    # code block
```

**Example**:
```python
if age < 13:
    if age < 2:
        print("You are a baby.")
    elif age < 7:
        print("You are a toddler.")
    else:
        print("You are a kid.")
elif age < 20:
    print("You are a teenager.")
else:
    print("You are an adult.")
```

## Loops

Loops are used to execute a block of code repeatedly.

### `for` Loops

A `for` loop is used for iterating over a sequence (like a list, tuple, or string).

```python
# Looping through a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# Looping through a range of numbers
for i in range(5):  # range(5) generates numbers from 0 to 4
    print(i)
```

### `while` Loops

A `while` loop executes a block of code as long as a specified condition is `True`.

```python
count = 0
while count < 5:
    print(count)
    count += 1  # It's crucial to have a way to exit the loop!
```

## List Comprehensions

```python
# TODO: fill the section
```

## Basic Data Manipulation

This involves using the concepts we've learned to perform simple operations on collections of data.

### Example: Filtering Data

Let's say we have a list of numbers and we want to create a new list containing only the even numbers.

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = []

for number in numbers:
    if number % 2 == 0:  # The modulus operator % gives the remainder
        even_numbers.append(number)

print(even_numbers)  # Output: [2, 4, 6, 8, 10]
```

This example combines lists, loops, and conditional statements to manipulate dataâ€”a fundamental skill in data science.ðŸ˜ƒ