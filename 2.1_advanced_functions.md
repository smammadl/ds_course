# 2.1: Advanced Functions and Functional Programming for Data Processing

## Lambda Functions

Lambda functions are small, anonymous functions defined with the `lambda` keyword. They can have any number of arguments but only one expression.

**The basic idea:** Why define a full function with `def` for a small, one-time task? A lambda function is a shortcut.

**Syntax:** `lambda arguments: expression`

**Example:** A lambda function that adds two numbers.

```python
add = lambda a, b: a + b
print(add(5, 3))  # Output: 8
```

This is equivalent to:

```python
def add_def(a, b):
    return a + b
```

**When to use Lambda Functions?**

They are most useful when you need a small function for a short period, often as an argument to a higher-order function (a function that takes other functions as arguments), like `map`, `filter`, or `sorted`.

**Example with `sorted()`:**

```python
# A list of tuples (name, age)
people = [('Alice', 30), ('Bob', 25), ('Charlie', 35)]

# Sort by age (the second element of the tuple)
sorted_people = sorted(people, key=lambda person: person[1])
print(sorted_people)  # Output: [('Bob', 25), ('Alice', 30), ('Charlie', 35)]
```

Here, `lambda person: person[1]` is a short function that tells `sorted` to use the age for sorting.

## `map`, `filter`, and `reduce`

These are three powerful functions that allow you to apply functions to sequences (like lists).

### `map()`

The `map()` function applies a given function to every item of an iterable (like a list) and returns a `map` object (which is an iterator).

**Syntax:** `map(function, iterable)`

**Example:** Squaring every number in a list.

```python
numbers = [1, 2, 3, 4]
squared_numbers = map(lambda x: x**2, numbers)

# Convert the map object to a list to see the result
print(list(squared_numbers))  # Output: [1, 4, 9, 16]
```

### `filter()`

The `filter()` function creates an iterator from elements of an iterable for which a function returns `True`.

**Syntax:** `filter(function, iterable)`

**Example:** Filtering even numbers from a list.

```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)

# Convert the filter object to a list
print(list(even_numbers))  # Output: [2, 4, 6]
```

### `reduce()`

The `reduce()` function applies a function of two arguments cumulatively to the items of an iterable, from left to right, so as to reduce the iterable to a single value. It's part of the `functools` module.

**Syntax:** `functools.reduce(function, iterable)`

**Example:** Calculating the product of all numbers in a list.

```python
from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 24 (1*2=2, 2*3=6, 6*4=24)
```

## List Comprehensions

List comprehensions provide a concise way to create lists. They are often more readable and performant than using `for` loops.

**Basic Syntax:** `[expression for item in iterable]`

**Example:** Creating a list of squares.

```python
# Using a for loop
squares_loop = []
for i in range(5):
    squares_loop.append(i**2)

# Using list comprehension
squares_comp = [i**2 for i in range(5)]

print(squares_comp)  # Output: [0, 1, 4, 9, 16]
```

### Adding a Condition

You can add an `if` condition to filter items.

**Syntax:** `[expression for item in iterable if condition]`

**Example:** Getting squares of even numbers only.

```python
even_squares = [i**2 for i in range(10) if i % 2 == 0]
print(even_squares)  # Output: [0, 4, 16, 36, 64]
```

### `if-else` in List Comprehensions

You can also use an `if-else` statement.

**Syntax:** `[expression if condition else other_expression for item in iterable]`

**Example:** Label numbers as 'even' or 'odd'.

```python
labels = ['even' if i % 2 == 0 else 'odd' for i in range(5)]
print(labels)  # Output: ['even', 'odd', 'even', 'odd', 'even']
```

## Dictionary and Set Comprehensions

Similar to list comprehensions, you can create dictionaries and sets in a concise way.

### Dictionary Comprehensions

**Syntax:** `{key_expression: value_expression for item in iterable}`

**Example:** Creating a dictionary of numbers and their squares.

```python
squared_dict = {x: x**2 for x in range(5)}
print(squared_dict)  # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

### Set Comprehensions

**Syntax:** `{expression for item in iterable}`

**Example:** Creating a set of unique squared numbers from a list with duplicates.

```python
numbers = [1, 2, 2, 3, 3, 3, 4]
unique_squares_set = {x**2 for x in numbers}
print(unique_squares_set)  # Output: {1, 4, 9, 16}
```

## Error Handling (`try...except`)

Errors, or exceptions, are bound to happen in programs. Error handling allows your program to deal with these exceptions gracefully without crashing.

The `try...except` block is used for this.
- The `try` block contains the code that might raise an exception.
- The `except` block contains the code that runs if an exception occurs.

**Example:** Handling division by zero.

```python
try:
    result = 10 / 0
except ZeroDivisionError:
    result = "You can't divide by zero!"

print(result) # Output: You can't divide by zero!
```

### Handling Multiple Exceptions

You can handle different types of exceptions.

```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ValueError:
    print("That was not a valid number!")
except ZeroDivisionError:
    print("You can't divide by zero!")
```

### `else` and `finally` clauses

- `else`: This block runs only if no exceptions were raised in the `try` block.
- `finally`: This block runs no matter what, whether an exception occurred or not. It's often used for cleanup operations, like closing a file.

**Example:**

```python
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Invalid input.")
else:
    print(f"You entered {num}.")
finally:
    print("Execution finished.")
```

## Raising Exceptions (`raise`)

Sometimes, you need to raise an exception intentionally in your code if a certain condition is not met. The `raise` keyword is used for this.

**Example:** A function that only accepts positive numbers.

```python
def process_positive_number(n):
    if n <= 0:
        raise ValueError("The number must be positive!")
    print(f"{n} is a valid number.")

try:
    process_positive_number(10)   # This will work
    process_positive_number(-5)   # This will raise an error
except ValueError as e:
    print(f"Error: {e}")

# Output:
# 10 is a valid number.
# Error: The number must be positive!
```

By raising an exception, you can signal that something went wrong, and this can be caught and handled by an `except` block.
