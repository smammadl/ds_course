# 2.2: Object-Oriented Programming (OOP)

## Introduction to OOP

**What is an Object?**

In the real world, everything can be thought of as an object. A car, a dog, a personâ€”they are all objects. Each object has:
- **Attributes:** Characteristics or properties (e.g., a car has a color, model, and year).
- **Methods:** Actions or behaviors it can perform (e.g., a car can `start()`, `drive()`, and `stop()`).

OOP applies this concept to programming. It allows us to structure our code in a way that models real-world objects, making our programs more organized, reusable, and easier to understand.

**Why use OOP?**

- **Modularity:** It breaks down complex problems into smaller, manageable objects.
- **Reusability:** Objects can be reused across different programs (e.g., the `Car` object you define once can be used wherever you need a car).
- **Maintainability:** It's easier to update and maintain code that is well-organized into objects.

## Creating Classes

A **class** is a blueprint for creating objects. It defines the attributes and methods that all objects of that class will have. An **object** (or **instance**) is a specific creation based on that blueprint.

**Think of it like this:** A `CookieCutter` is the class. The `cookies` you make with it are the objects.

### Defining a Class

The `class` keyword is used to define a class.

```python
class Dog:
    # Class attribute (same for all instances of the class)
    species = "Canis familiaris"

    # Initializer / Instance attributes
    def __init__(self, name, age):
        self.name = name  # self.name is an instance attribute
        self.age = age

    # Instance method
    def bark(self):
        return "Woof!"

    def describe(self):
        return f"{self.name} is {self.age} years old."
```

**Key Components:**
- **`__init__` method:** This special method is called the "constructor." It's executed when you create a new object of the class. It's used to initialize the object's attributes.
- **`self`:** The `self` parameter is a reference to the current instance of the class. It is used to access variables that belong to the class. It must be the first parameter of any method in the class.
- **Attributes:** `name` and `age` are instance attributes, specific to each `Dog` object. `species` is a class attribute, shared by all `Dog` objects.
- **Methods:** `bark()` and `describe()` are instance methods, which are functions defined inside a class that can be called on an object.

### Creating an Instance (Object)

To create an object from a class, you "call" the class like a function.

```python
# Create two Dog objects
my_dog = Dog("Buddy", 5)
your_dog = Dog("Lucy", 3)

# Accessing attributes
print(my_dog.name)   # Output: Buddy
print(your_dog.age)    # Output: 3

# Calling methods
print(my_dog.bark())     # Output: Woof!
print(your_dog.describe()) # Output: Lucy is 3 years old.
```

## Inheritance

Inheritance is a mechanism that allows a new class (the **child class** or **subclass**) to inherit attributes and methods from an existing class (the **parent class** or **superclass**). This promotes code reuse.

**Example:** Let's create a `GoldenRetriever` class that inherits from `Dog`.

```python
class GoldenRetriever(Dog):  # Inherits from Dog
    def fetch(self, item):
        return f"{self.name} is fetching the {item}!"
```

The `GoldenRetriever` class automatically has all the attributes and methods of the `Dog` class, plus its own new `fetch` method.

```python
retriever = GoldenRetriever("Goldie", 2)
print(retriever.describe())  # Method from parent class
print(retriever.fetch("ball")) # Method from child class

# Output:
# Goldie is 2 years old.
# Goldie is fetching the ball!
```

You can also **override** parent methods by defining a method with the same name in the child class.

## Polymorphism

Polymorphism means "many forms." In programming, it refers to the ability of different objects to respond to the same method call in different ways.

**Example:** Let's say we have a `Cat` class and a `Dog` class, both with a `speak` method.

```python
class Cat:
    def speak(self):
        return "Meow!"

class Dog:
    def speak(self):
        return "Woof!"

# A function that can work with any animal that can "speak"
def animal_sound(animal):
    print(animal.speak())

my_dog = Dog()
my_cat = Cat()

animal_sound(my_dog)  # Output: Woof!
animal_sound(my_cat)  # Output: Meow!
```

Here, the `animal_sound` function doesn't need to know if the object is a `Dog` or a `Cat`. It just calls the `speak()` method, and the object itself knows how to respond correctly. This makes the code more flexible and extensible.

## Encapsulation

Encapsulation is the bundling of data (attributes) and methods that operate on the data into a single unit (a class). It also involves restricting direct access to some of an object's components, which is a way to prevent the accidental modification of data.

In Python, there is no strict "private" keyword like in some other languages. However, by convention, we can indicate that an attribute is intended for internal use by prefixing its name with an underscore (`_`).

**Example:**

```python
class Car:
    def __init__(self, make, model):
        self.make = make          # Public attribute
        self._model = model         # "Protected" attribute
        self.__speed = 0          # "Private" attribute (name mangling)

    def accelerate(self):
        self.__speed += 10

    def get_speed(self):
        return self.__speed
```

- **`make`:** Publicly accessible.
- **`_model`:** Convention says you shouldn't access this directly from outside the class.
- **`__speed`:** Two underscores cause "name mangling." Python changes the name to `_Car__speed`, making it harder to access from outside.

This principle helps in creating a clear interface for your objects and preventing unintended changes to their internal state.

## Data Classes

Introduced in Python 3.7, data classes are a way to automatically add special methods like `__init__()`, `__repr__()`, and `__eq__()` to your classes. They are great for classes that primarily store data.

You use the `@dataclass` decorator.

**Before Data Classes:**

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

    def __eq__(self, other):
        return self.name == other.name and self.age == other.age
```

**With Data Classes:**

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

p1 = Person("Alice", 30)
p2 = Person("Alice", 30)

print(p1)       # Output: Person(name='Alice', age=30)
print(p1 == p2) # Output: True
```

As you can see, the data class version is much more concise and provides useful default behaviors without writing boilerplate code.
