# 2.1: Advanced Functions and Functional Programming for Data Processing

## What is Functional Programming?

Functional Programming (FP) is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data.

Key principles relevant to data processing include:

*   **Pure Functions:** A pure function's return value is the same for the same arguments. It has no side effects, meaning it doesn't change any state outside the function (like modifying a global variable or printing to the console). This makes code more predictable and easier to test.
*   **Immutability:** Data is treated as immutable, meaning it cannot be changed after it's created. Instead of modifying existing data structures, you create new ones. This helps prevent bugs related to unintended data changes.
*   **First-Class Functions:** Functions are treated like any other variable. They can be passed as arguments to other functions, returned from functions, and assigned to variables.
*   **Avoiding Side Effects:** Functional programming aims to minimize side effects (modifications of state outside the function's scope).

In data science, applying functional principles with tools like `lambda`, `map`, and `filter` leads to more concise, readable, and less error-prone code for data transformation and processing pipelines.

## Lambda Functions

Lambda functions are small, anonymous functions defined with the `lambda` keyword. They can have any number of arguments but only one expression.

**The basic idea:** Why define a full function with `def` for a small, one-time task? A lambda function is a shortcut.

**Syntax:** `lambda arguments: expression`

**Example:** A function that adds two numbers.
```python
def add_def(a, b):
    result = a + b
    return result
print(add_def(5, 3))  # Output: 8
```

A simpler but equivalent function is:
```python
def add_def(a, b):
    return a + b
print(add_def(5, 3))  # Output: 8
```

You can write the same function in a single line:

```python
def add_def(a, b): return a + b
print(add_def(5, 3))  # Output: 8
```

A lambda function is a more concise way to write the same function:
```python
add = lambda a, b: a + b
print(add(5, 3))  # Output: 8
```

**When to use Lambda Functions?**

They are most useful when you need a small function for a short period, often as an argument to a higher-order function (a function that takes other functions as arguments), like `map`, `filter`, or `sorted`.

**Example with `sorted()`:**

```python
# A list of tuples (name, age)
people = [('Alice', 30), ('Bob', 25), ('Charlie', 35)]

# Sort by age (the second element of the tuple)
sorted_people = sorted(people, key=lambda person: person[1])
print(sorted_people)  # Output: [('Bob', 25), ('Alice', 30), ('Charlie', 35)]
```

Here, `lambda person: person[1]` is a short function that tells `sorted` to use the age for sorting.

## `map`, `filter`, and `reduce`

These are three powerful functions that allow you to apply functions to sequences (like lists).

### `map()`

The `map()` function applies a given function to every item of an iterable (like a list) and returns a `map` object (which is an iterator).

**Syntax:** `map(function, iterable)`

**Example:** Squaring every number in a list.

```python
numbers = [1, 2, 3, 4]
squared_numbers = map(lambda x: x**2, numbers)

# Convert the map object to a list to see the result
print(list(squared_numbers))  # Output: [1, 4, 9, 16]
```

### `filter()`

The `filter()` function creates an iterator from elements of an iterable for which a function returns `True`.

**Syntax:** `filter(function, iterable)`

**Example:** Filtering even numbers from a list.

```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)

# Convert the filter object to a list
print(list(even_numbers))  # Output: [2, 4, 6]
```

### `reduce()`

The `reduce()` function applies a function of two arguments cumulatively to the items of an iterable, from left to right, so as to reduce the iterable to a single value. It's part of the `functools` module.

**Syntax:** `functools.reduce(function, iterable)`

**Example:** Calculating the product of all numbers in a list.

```python
from functools import reduce

numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 24 (1*2=2, 2*3=6, 6*4=24)
```

> **Note:** Functions that accept other functions as arguments are called higher-order functions. `map`, `filter`, and `reduce` are all higher-order functions. We can create our own higher-order functions by passing functions as arguments to other functions.
> ```python
> def apply_function(func, value):
>     return func(value)
> 
> def square(x):
>     return x**2
> 
> def cube(x):
>     return x**3
> 
> print(apply_function(square, 5))  # Output: 25
> print(apply_function(cube, 5))  # Output: 125
> ```


## List Comprehensions

List comprehensions provide a concise way to create lists. They are often more readable and performant than using `for` loops.

**Basic Syntax:** `[expression for item in iterable]`

**Example:** Creating a list of squares.

```python
# Using a for loop
squares_loop = []
for i in range(5):
    squares_loop.append(i**2)

# Using list comprehension
squares_comp = [i**2 for i in range(5)]

print(squares_comp)  # Output: [0, 1, 4, 9, 16]
```

### Adding a Condition

You can add an `if` condition to filter items.

**Syntax:** `[expression for item in iterable if condition]`

**Example:** Getting squares of even numbers only.

```python
even_squares = [i**2 for i in range(10) if i % 2 == 0]
print(even_squares)  # Output: [0, 4, 16, 36, 64]
```

### `if-else` in List Comprehensions

You can also use an `if-else` statement.

**Syntax:** `[expression if condition else other_expression for item in iterable]`

**Example:** Label numbers as 'even' or 'odd'.

```python
labels = ['even' if i % 2 == 0 else 'odd' for i in range(5)]
print(labels)  # Output: ['even', 'odd', 'even', 'odd', 'even']
```

> **Exercise:** Use list comprehension to convert a list of celcius temperatures to fahrenheit temperatures.

## Dictionary and Set Comprehensions

Similar to list comprehensions, you can create dictionaries and sets in a concise way.

### Dictionary Comprehensions

**Syntax:** `{key_expression: value_expression for item in iterable}`

**Example:** Creating a dictionary of numbers and their squares.

```python
squared_dict = {x: x**2 for x in range(5)}
print(squared_dict)  # Output: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

### Set Comprehensions

**Syntax:** `{expression for item in iterable}`

**Example:** Creating a set of unique squared numbers from a list with duplicates.

```python
numbers = [1, 2, 2, 3, 3, 3, 4]
unique_squares_set = {x**2 for x in numbers}
print(unique_squares_set)  # Output: {1, 4, 9, 16}
```

> **Note:** Python does not have a direct "tuple comprehension" syntax like list comprehensions. To create a tuple using a similar approach, you should use a generator expression (parentheses) and pass it to the `tuple()` constructor.
> ```python
> unique_squares_tuple = tuple(x**2 for x in numbers)
> print(unique_squares_tuple)  # Output: (1, 4, 9, 16)
> ```

## Error Handling (`try...except`)

Errors, or exceptions, are bound to happen in programs. Error handling allows your program to deal with these exceptions gracefully without crashing.

The `try...except` block is used for this.
- The `try` block contains the code that might raise an exception.
- The `except` block contains the code that runs if an exception occurs.
- The `else` block contains the code that runs if no exception occurs in the try block.
- The `finally` block contains the code that always runs, whether an exception occurs or not.

Syntax:
```python
try:
    # code that might raise an exception
except ExceptionType:
    # code to run if an exception occurs
else:
    # code to run if no exception occurs in the try block
finally:
    # code that always runs, whether an exception occurs or not
```

> **Note:** The `ExceptionType` is the type of exception that is raised. You can use no exception type, a specific exception type, or a generic `Exception` type to catch all exceptions.
> ```python
> except ExceptionType as e:
>     # code to run if an exception occurs and assign the exception to a variable
> except ExceptionType:
>     # without assigning the exception to a variable
> except Exception as e:
>     # generic exception handling
> except:
>     # for all exceptions
> ```

**Example:** Handling division by zero.

```python
try:
    result = 10 / 0
except ZeroDivisionError:
    result = "You can't divide by zero!"

print(result) # Output: You can't divide by zero!
```

### Handling Multiple Exceptions

You can handle different types of exceptions.

```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ValueError:
    print("That was not a valid number!")
except ZeroDivisionError:
    print("You can't divide by zero!")
```

### `else` and `finally` clauses

- `else`: This block runs only if no exceptions were raised in the `try` block.
- `finally`: This block runs no matter what, whether an exception occurred or not. It's often used for cleanup operations, like closing a file.

**Example:**

```python
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Invalid input.")
else:
    print(f"You entered {num}.")
finally:
    print("Execution finished.")
```

## Raising Exceptions (`raise`)

Sometimes, you need to raise an exception intentionally in your code if a certain condition is not met. The `raise` keyword is used for this.

**Example:** A function that only accepts positive numbers.

```python
def process_positive_number(n):
    if n <= 0:
        raise ValueError("The number must be positive!")
    print(f"{n} is a valid number.")

try:
    process_positive_number(10)   # This will work
    process_positive_number(-5)   # This will raise an error
except ValueError as e:
    print(f"Error: {e}")

# Output:
# 10 is a valid number.
# Error: The number must be positive!
```

By raising an exception, you can signal that something went wrong, and this can be caught and handled by an `except` block.

## Assertions

Assertions are a way to check if a condition is true. If the condition is false, an `AssertionError` is raised. They are used to catch errors in the code that should never happen.

**Syntax:** `assert condition, message`

**Example:**

```python
assert 1 == 1, "1 is not equal to 1"
```

