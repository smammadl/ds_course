# 2.3: Advanced Data Structures and Iterators

## Args and Kwargs (`*args` and `**kwargs`)

In Python, `*args` and `**kwargs` are used to handle an arbitrary number of arguments in a function. This provides flexibility when you don't know in advance how many arguments will be passed to your function.

### `*args` (Arbitrary Positional Arguments)

The `*args` syntax allows a function to accept any number of positional arguments. These arguments are collected into a tuple.

**Think of it like this:** Imagine you have a function that sums numbers. You might want to sum 2 numbers, 3 numbers, or even 10 numbers. Instead of creating different functions for each case, you can use `*args`.

**Example:**

```python
def sum_all(*args):
    """
    This function sums all the numbers passed as arguments.
    """
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))         # Output: 6
print(sum_all(10, 20, 30, 40))  # Output: 100
```

In this example, `args` is a tuple containing all the positional arguments passed to the function. The name `args` is a convention; you could use any other name, like `*numbers`.

### `**kwargs` (Arbitrary Keyword Arguments)

The `**kwargs` syntax allows a function to accept any number of keyword arguments (arguments with names). These arguments are collected into a dictionary.

**Think of it like this:** Imagine a function that prints user information. Different users might have different attributes (e.g., name, age, city). `**kwargs` lets you handle this flexibility.

**Example:**

```python
def display_user_info(**kwargs):
    """
    This function displays user information passed as keyword arguments.
    """
    for key, value in kwargs.items():
        print(f"{key}: {value}")

display_user_info(name="Alice", age=30)
# Output:
# name: Alice
# age: 30

display_user_info(name="Bob", city="New York", occupation="Developer")
# Output:
# name: Bob
# city: New York
# occupation: Developer
```

Here, `kwargs` is a dictionary where keys are the argument names and values are the argument values.

### Using `*args` and `**kwargs` Together

You can use both in a single function. The order must be `*args` before `**kwargs`.

**Example:**

```python
def process_data(*args, **kwargs):
    print("Positional arguments (args):", args)
    print("Keyword arguments (kwargs):", kwargs)

process_data(1, 2, 'hello', name='Charlie', status='active')
# Output:
# Positional arguments (args): (1, 2, 'hello')
# Keyword arguments (kwargs): {'name': 'Charlie', 'status': 'active'}
```

## Generators

A generator is a special type of iterator, created using a function with the `yield` keyword. Unlike regular functions that compute a value and return it, generators produce a sequence of values over time. They "yield" one value, pause their state, and wait for the next value to be requested.

**Why use Generators?**

The main advantage is **memory efficiency**. Generators don't store the entire sequence of items in memory. They generate each item on-the-fly, which is incredibly useful when working with very large datasets or infinite sequences.

**Example:** A generator for squaring numbers.

```python
def square_generator(nums):
    for i in nums:
        yield i * i

my_nums = [1, 2, 3, 4, 5]
squares = square_generator(my_nums)

# The values are generated one by one as we iterate
print(next(squares))  # Output: 1
print(next(squares))  # Output: 4

# We can also use it in a for loop
for sq in squares:
    print(sq)
# Output:
# 9
# 16
# 25
```

You can also create simple generators using **generator expressions**, which look like list comprehensions but with parentheses.

```python
squares_expr = (x*x for x in my_nums)
print(squares_expr) # Output: <generator object <genexpr> at ...>
```

## Decorators

A decorator is a function that takes another function as an argument, adds some kind of functionality, and then returns another function. This is a powerful way to modify or enhance the behavior of functions without permanently changing their code.

**Think of it like this:** A decorator is like wrapping a gift. The gift (the original function) stays the same, but now it has an extra layer of wrapping (the decorator's functionality) around it.

**Example:** A simple decorator to time a function's execution.

```python
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Execution time for {func.__name__}: {end_time - start_time} seconds")
        return result
    return wrapper

@timer_decorator
def long_running_function():
    time.sleep(2)
    print("Function finished.")

long_running_function()

# Output:
# Function finished.
# Execution time for long_running_function: 2.0... seconds
```

The `@timer_decorator` syntax is "syntactic sugar" for `long_running_function = timer_decorator(long_running_function)`.

## Reading and Writing Files

Interacting with files is a fundamental task. Python provides a straightforward way to read from and write to files.

**The `open()` function:**
- `open('filename.txt', 'r')`: Open for reading (default mode).
- `open('filename.txt', 'w')`: Open for writing (will overwrite the file if it exists).
- `open('filename.txt', 'a')`: Open for appending (will add to the end of the file).
- `open('filename.txt', 'r+')`: Open for both reading and writing.

**Example:**

```python
# Writing to a file
with open('hello.txt', 'w') as f:
    f.write('Hello, World!\n')
    f.write('This is a new line.')

# Reading from a file
with open('hello.txt', 'r') as f:
    content = f.read()
    print(content)

# Output:
# Hello, World!
# This is a new line.
```

## Context Managers (`with` statement)

The `with` statement is used to wrap the execution of a block of code within methods defined by a context manager. It simplifies resource management, such as automatically closing files after you are done with them.

In the file I/O example above, `with open(...) as f:` is using a context manager. The file `f` is guaranteed to be closed when the `with` block is exited, even if errors occur inside it. This is the recommended way to handle files and other resources.

## Introduction to Python's Standard Library

Python comes with a "batteries-included" philosophy, meaning it has a rich and extensive standard library. This library contains a wide range of modules and packages that provide tools for many common programming tasks, from working with text to handling network connections. You don't need to install them separately.

## Collections Module

The `collections` module provides specialized, high-performance container datatypes that are alternatives to Python's general-purpose built-in containers like `dict`, `list`, `set`, and `tuple`.

### `Counter`
A `Counter` is a dictionary subclass for counting hashable objects.

```python
from collections import Counter

my_list = ['a', 'b', 'c', 'a', 'b', 'a']
counts = Counter(my_list)
print(counts)        # Output: Counter({'a': 3, 'b': 2, 'c': 1})
print(counts['a'])   # Output: 3
```

### `defaultdict`
A `defaultdict` is like a regular dictionary, but if you try to access a key that doesn't exist, it will automatically create it with a default value, instead of raising a `KeyError`.

```python
from collections import defaultdict

# Create a defaultdict where the default value for a missing key is 0
d = defaultdict(int)
d['a'] = 1
print(d['a']) # Output: 1
print(d['b']) # Output: 0 (b was not there, so it was created with int(), which is 0)
```

### `deque`
A `deque` (deck) is a double-ended queue. It's optimized for fast appends and pops from both ends.

```python
from collections import deque

q = deque([1, 2, 3])
q.append(4)       # Add to the right
q.appendleft(0)   # Add to the left
print(q)          # Output: deque([0, 1, 2, 3, 4])
q.pop()           # Remove from the right
q.popleft()       # Remove from the left
print(q)          # Output: deque([1, 2, 3])
```

## Itertools Module

The `itertools` module provides functions for creating and using iterators for efficient looping.

### `chain`
Combines multiple iterators into a single one.
```python
from itertools import chain

list1 = [1, 2, 3]
list2 = ['a', 'b']
combined = chain(list1, list2)
for item in combined:
    print(item, end=' ') # Output: 1 2 3 a b
```

### `product`
Creates the Cartesian product of input iterables. It's equivalent to nested for loops.
```python
from itertools import product

nums = [1, 2]
letters = ['A', 'B']
prod = product(nums, letters)
print(list(prod)) # Output: [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]
```

### `permutations` and `combinations`
These generate all possible orderings or groupings of items.
```python
from itertools import permutations, combinations

items = ['a', 'b', 'c']
# All possible orderings of length 2
print(list(permutations(items, 2))) # Output: [('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]

# All unique combinations of length 2
print(list(combinations(items, 2))) # Output: [('a', 'b'), ('a', 'c'), ('b', 'c')]
```
